#Include 'Protheus.ch'
#Include 'Parmtype.ch'

User Function SF7301F()

Local aEstrut		:= {}
Local cArqTxt		:= ""
Local cCadastro		:= "Atualização de Produtos"
Local cDescri		:= "Este programa irá realizar a atualização de Produtos"
Local aSays			:= {}
Local aButtons		:= {}
Local nOpca 		:= 0
Local lRet			:= .F.

Private lMsErroAuto	:= .F.
Private cMemo  		:= ""
	
	aAdd(aSays, cDescri)

	aAdd(aButtons, { 1, .T., {|o| nOpca := 1, FechaBatch()} })
	aAdd(aButtons, { 2, .T., {|o| FechaBatch() } })

	FormBatch(cCadastro, aSays, aButtons)

	If nOpca == 1
		If MsgYesNo("Confirma a atualização de Produtos?","Confirmar")
			
			//cArqTxt := Upper(cGetFile('*.csv', 'Selecionar arquivo', 1,'C:\', .F., nOR( GETF_LOCALHARD, GETF_RETDIRECTORY ), .F.))
			cArqTxt := Upper( cGetFile('Arquivos CSV (*.csv) |*.csv|', 'Selecione o Arquivo', , 'C:\', .T., nOR( GETF_LOCALHARD, GETF_MULTISELECT ), .F., .T.) )
			
			//Abre o Arquivo
			nHdl := fOpen(cArqTxt, 68)
		
			If nHdl == -1
				MsgAlert("O arquivo de nome " + cArqTxt + " nao pode ser aberto! Verifique os parametros.", "Atenção")
				Return
			Endif
		
			Processa({ |lEnd| aEstrut 	:= FVldCsv(cArqTxt) }, "Lendo arquivo CSV de produtos")
			Processa({ |lEnd| lRet 		:= FImpSB1(aEstrut) }, "Atualizando Registros")
		
			If lRet
				MsgInfo("Fim da Atualização do cadastro de produtos", "Atenção")
			EndIf
			
			If !Empty(cMemo)
				MemoWrite( "C:/temp/SF7301F.txt", cMemo )
				MsgInfo("Houveram inconsistências na importação, verifique o arquivo de log", "Atenção")
			EndIf
			
		EndIf
	EndIf
	
Return( Nil )

Static Function FVldCsv(cArquivo)
	
	Local cBuffer     := ""
	Local cAux        := ""
	Local cString     := ""
	Local cSeparador  := ""  //Verifica o tipo de separador do arquivo texto
	Local aTmp        := {}
	Local aEstrutura  := {}
	Local nCont       := 0
	Local cEof        := Chr(10) + Chr(13)
	Local nRec        := 0
	Local lAspa       := .F.

	//Leitura da quantidade de Registros do Arquivo
	FT_FUSE(cArquivo)
	FT_FGOTOP()
	
	While !FT_FEOF()
		nRec++
		FT_FSKIP()
	End

	ProcRegua(nRec)

	//Leitura do arquivo e verificacao do ultimo caracter da linha lida para  consistencia da pesquisa
	FT_FGOTOP()

	While !FT_FEOF()
	
		cBuffer := AllTrim(FT_FREADLN())
	
		If At(";",cBuffer) > 0
			cSeparador:= ";" 
		Else //linha de arquivo incorreta.
			IncProc()
			FT_FSKIP()
			Loop
		Endif
	
		If (SubStr(cBuffer, Len(cBuffer), 1) <> cSeparador)
			cBuffer += cSeparador + cEof + cSeparador
		Else
			cBuffer += cEof + cSeparador
		Endif
	
		//Incrementa a regua
		IncProc()
	
		//Carrega o array aEstrutura com o resultado da Importacao
		cLinha := fTAcento(cBuffer)
		lAspa  := .F.

		For nCont := 1 To Len(cBuffer)
		
			cAux   := SubStr(cLinha,1,1)
			cLinha := SubStr(cLinha,2)
			
			If (cAux == cEof .Or. cAux == Chr(10)) 
				Exit
			Endif
		
			//Sao verificadas as marcacoes feitas pelo Excel para concatenacao de strings
			Do Case
			
				Case cAux == '"'
					lAspa := !lAspa
					
				Case cAux == cSeparador .And. !lAspa
					aAdd(aTmp,cString)
					cString := ""
					
				OtherWise
					cString += cAux
					
			EndCase
		
		Next nCont
	
		For nCont := Len(aTmp)+1 To 11
			aAdd(aTmp,"")
		Next nCont
	
		//Validacao para nao salvar registros sem entidades
		If !Empty(aTmp[1]) .OR. !Empty(aTmp[2])
			aAdd(aEstrutura,aTmp)
			aTmp := {}
		Endif
		
		FT_FSKIP()
	End

	FT_FUSE()

Return( aEstrutura )

Static Function FImpSB1(p_aEstrut)
	
Local aProduto 		:= {}
Local aCampos 		:= {}
Local aCposErr		:= {}
Local lRet 			:= .F.
Local nContador 	:= 0
Local nPosCod		:= 0		
	
	Default p_aEstrut := 0
		
	If Len(p_aEstrut) <= 1
		Alert('Por favor, verifique o layout do arquivo CSV, a estrutura esta incorreta!')
		Return( lRet )
	EndIf

	dbSelectArea("SX3")
	dbSetOrder(2)
	
	//Verifico se os campos informados no cabeçalho existem na SX3
	For i := 1 To Len(p_aEstrut[1])
		If MsSeek(AllTrim(p_aEstrut[1][i])) 
			aAdd(aCampos, AllTrim(p_aEstrut[1][i]))
		Else
			aAdd(aCposErr, p_aEstrut[1][i])
			cMemo += "Campo do cabeçalho não encontrado: " + p_aEstrut[1][i] + CRLF
		EndIf
	Next i

	If !Empty(aCposErr)
		Alert('Existem campos informados que não existem no dicionário. Por favor verifique!')
		Return( lRet )
	EndIf
	
	//Verifico se existe o campo B1_COD, que será utilizado na busca de um registro existente
	nPosCod := Ascan(aCampos,{|x| x == "B1_COD"})
	
	If nPosCod <> 0
	
		ProcRegua(Len(p_aEstrut))
		
		DbSelectArea('SB1')
		SB1->(DbSetOrder(1))
		SB1->(DbGoTop())
		
		For i := 2 To Len(p_aEstrut)
		
			//Completo com Zero a esquerda, caso o valor informado para o campo B1_COD não seja compatível
			If Len(AllTrim(p_aEstrut[i][nPosCod])) <  TamSX3("B1_COD")[1] 
						
				p_aEstrut[i][nPosCod] := StrZero( Val(p_aEstrut[i][nPosCod]), TamSX3("B1_COD")[1] )
			
			EndIf
				
			//Verifico se o produto existe
			If MsSeek( FwXFilial('SB1') + AllTrim(p_aEstrut[i][nPosCod]) )
				
				_nOpc		:= 4
				aProduto	:= {}
				
				For nX := 1 To Len(aCampos)
					aAdd(aProduto, {aCampos[nX], p_aEstrut[i][nX], Nil})
				Next nX 		
				
				lMsErroAuto := .F.
				
				Begin Transaction
	
					MSExecAuto({|x,y| Mata010(x,y)}, aProduto, _nOpc) //3- Inclusao, 4- Alteracao, 5- Exclusao
					
					If lMsErroAuto
						MostraErro()
						DisarmTransaction()
					Else
						nContador++
					EndIf
				
				End Transaction
				
			Else
				cMemo += 'O Produto: ' + AllTrim( p_aEstrut[i][nPosCod] ) + ', não esta cadastrado no sistema, favor verificar!' + CRLF
			EndIf
					
			IncProc()
			
		Next i
		
		SB1->( DbCloseArea() )
		
	Else
		Alert('Não é possível Iniciar importação porque não foi encontrado o campo B1_COD')
		Return( lRet )
	EndIf

	If nContador > 0
		lRet := .T.
	EndIf
	
Return( lRet )