//#INCLUDE "LOJA701A.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "MSMGADD.CH"
#INCLUDE "TCBROWSE.CH"

Static aMoeda
Static lFreteAlt	:= .F.							//Indica que ocorreu alteracao no valor do frete, despesa ou seguro.
Static lCenVenda 	:= SuperGetMv("MV_LJCNVDA",,.F.)
Static nDescAnt										//Bkp do valor de desconto Global
Static oMotivoDes	:= Nil
Static lMvljpdvpa	:= FindFunction("LjxBGetPaf") .AND. LjxBGetPaf()[2] //Indica se é pdv  
Static lValidSenha  :=.F.							//Variavel logica de validacao de senha
Static lR5			:= GetRpoRelease() >= "R5"		// Indica se o release e 11.5
Static lLjMVRecIss	:= SuperGetMV("MV_LJRECIS",,.F.)// Indica se ha desconto do iss no financeiro
Static lLjVfe		:= SuperGetMV("MV_LJVFE",,.F.)	// #VFE - Verifica se a rotina de Venda fora do estado esta ativa
Static lEmitNfce	:= FindFunction("LjEmitNFCe") .AND.  LjEmitNFCe() // Sinaliza se utiliza NFC-e
Static lLj7IsNoFun	:= FindFunction("Lj7IsNoFun")
Static lNovRegDesc  := SuperGetMV("MV_LJRGDES",,.F.) 
Static aTabsPrecos  := {}
Static aUltResult
#DEFINE MAXSAVERESULT 99999
   
/*/{Protheus.doc} SF0517X
(long_description)
@author j2a.luizjunior
@since 02/08/2017
@version 1.0
@example
(examples)
@see (links_or_references)
/*/

User Function SF0517X

	Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
	Local nItem 	  := aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ITEM"   })][2]	// Posicao da coluna Item
	Local nPosDescri  := aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_DESCRI" })][2]	// Posicao da Descricao do produto
	Local nPosQuant	  := aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"  })][2]	// Posicao da Quantidade
	Local nPosVlUnit  := aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT" })][2]	// Posicao do Valor unitario do item
	Local nPosVlrItem := aPosCpo[Ascan(aHeader,{|x| Alltrim(Upper(x[2])) == "LR_VLRITEM"})][2]	// Posicao do valor do item
	Local nPosProd    := aScan(aHeader,{|x| AllTrim(x[2]) == "LR_PRODUTO"})
	Local nPosUn      := aScan(aHeader,{|x| AllTrim(x[2]) == "LR_UM"     })
	Local nLin        := Len(aCols) 
	Local cRet        := ""
	Local lRet        := .F.
	//Private nPrecoTab		:= 0
	lRet := xLj7Prod(.T.,,.T.) 
	
	If lRet
		cRet := aCols[nLin][nPosProd]
		//aCols[n][nPosVlUnit]  := 0
		//aCols[n][nPosVlrItem] := 0		
	Else
		cRet := ""
		aCols[n][nPosDescri]  := ""
		aCols[n][nPosQuant]   := 0
		aCols[n][nPosVlUnit]  := 0
		aCols[n][nPosVlrItem] := 0
	EndIf
	
Return cRet

/*/{Protheus.doc} xLj7Prod
(long_description)
@author j2a.luizjunior
@since 02/08/2017
@version 1.0
@param lValid, ${param_type}, (Descrição do parâmetro)
@param lBonus, ${param_type}, (Descrição do parâmetro)
@param lGarantia, ${param_type}, (Descrição do parâmetro)
@param lLjGrid, ${param_type}, (Descrição do parâmetro)
@param lSugestao, ${param_type}, (Descrição do parâmetro)
@param nKit, numérico, (Descrição do parâmetro)
@param cProdKit, character, (Descrição do parâmetro)
@param nItemKit, numérico, (Descrição do parâmetro)
@param lItemKit, ${param_type}, (Descrição do parâmetro)
@return ${return}, ${return_description}
@example
(examples)
@see (links_or_references)
/*/

Static Function xLj7Prod(lValid,lBonus,lGarantia,lLjGrid,lSugestao,nKit,cProdKit,nItemKit,lItemKit)
	
	Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
	Local aArea	  		:= GetArea()															// Armazena area atual (alias, order e recno)
	Local lRet			:= .T.																	// Retorno da funcao
	Local nRet1         := 1
	Local nItem 		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ITEM"})][2]	// Posicao da coluna Item
	Local nPosProd		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})][2]// Posicao da codigo do produto
	Local nPosDescri	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_DESCRI"})][2]	// Posicao da Descricao do produto
	Local nPosQuant		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]	// Posicao da Quantidade
	Local nPosVlUnit	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]	// Posicao do Valor unitario do item
	Local nPosUM		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_UM"})][2]		// Posicao da Unidade de Medida
	Local nPosDesc		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_DESC"})][2]		// Posicao do percentual de desconto
	Local nPosValDesc	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VALDESC"})][2]	// Posicao do valor de desconto
	Local nPosVlrItem	:= aPosCpo[Ascan(aHeader,{|x| Alltrim(Upper(x[2])) == "LR_VLRITEM"})][2]	// Posicao do valor do item
	Local nPosLPre		:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CODLPRE"})				// Posicao do código de lista de presentes
	Local nPosVdMost	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VDMOST"})					// Posicao do Tipo de Peça
	Local nPosPrdCob	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRDCOBE"})				// Posicao do codigo do Produto Cobertura
	Local nGarant	    := 0																		// Posicao do valor da garantia  
	Local nSerie	    := 0																		// Posicao do valor de série   
	Local nPosDtReserva	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_RESERVA"})			// Posicao do codigo da reserva
	Local nPosDtLocal  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOCAL"})				// Posicao do local (armazem)
	Local nPosValePre	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALEPRE"})			// Posicao do codigo do Vale Presente
	Local nPosPrcTab	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_PRCTAB"})						// Posicao do Preco de Tabela
	Local nMoedaPrv     := 1																		// Armazena a moeda usada no Prc. Venda
	Local lEstNeg 		:= (SuperGetMV("MV_ESTNEG",,"S") == "S") .OR. lMVLJPDVPA					// Indica se permite vender com estoque negativo
	Local lTrcMoeda     := SuperGetMV("MV_TRCMOED",,.T.)											// Indica se permite escolha de moeda
	Local cLocal 		:= ""																		// Armazena o local padrao
	Local cProduto 		:= Space(TamSx3("LR_PRODUTO")[1])											// Armazena cod. do produto
	Local lVAssConc	 	:= LjVassConc()																// Indica se o cliente utiliza a Vda Assistida Concomitante
	Local lLJ7036		:= ExistBlock("LJ7036")														// Ponto de entrada antes da impressao concomitante
	Local lTLJ7036		:= ExistTemplate( "LJ7036" )												// Ponto de entrada antes da impressao concomitante
	Local lRetPE		:= .T.																		// Retorno do ponto de entrada
	Local lValEst		:= .F.																		// Retorno da funcao Lj7VerEst (Verifica se o item tem etoque)
	Local lLJ7041		:= ExistBlock("LJ7041")														// Verifica a existencia do P.E.
	Local cValePre		:= Space(15)																// Variavel para auxiliar na captura de codigo de vale presente
	Local xLocal		:= ""																		// Variavel auxiliar ao P.E. LJ7041 que permite personalizar o almoxarifado de saida do produto
	Local nBkpVlruni   	:= 0      	 	  					 				 	   					// Backup do campo Valor Unitario do Produto no aCols
	Local nBkpQuant     := 0	   	  					 			 		 						// Backup do campo Quantidade o Item no aCols
	Local nBkpDesc      := 0	  		   			   						  						// Backup do campo Desconto do produto no aCols
	Local nBkpValDesc   := 0	 												 					// Backup do campo Valor de Desconto  no aCols
	Local nCount        := 0                                           	
	Local cBkpDescri	:= Space( TamSx3("LR_DESCRI")[1] )											// Backup do campo Descricao do Produto no aCols
	Local cBkpUm   		:= ""	 												 					// Backup do campo Unidade de Medida do Produto no aCols
	Local cBkpProd		:= ""	 											 						// Backup do campo Produto no aCols
	Local nBkpVlItem	:= 0	 											 						// Backup do campo Valor dO Item  no aCols
	Local lPcMult       := .F.																		// Verifica se o produto digitado na consulta existe.
	Local nPrecoTab		:= 0
	Local nRet			:= 0
	Local nAux			:= 0
	Local cRetorno		:= "" 
	Local lDescCab      := .F.											   							// Indica se houve desconto no total pela regra de desconto cenario de venda 
	Local xRet
	Local oLJCLocker 	:= If( FindFunction("LOJA0051") .And. SuperGetMV( "MV_LJILVLO",,"2" ) == "1", LJCGlobalLocker():New(), )
	Local lSuVend		:= SuperGetMV("MV_LJSUAUT",,.F.) 											// sugestao de vendas automatica
	Local lR5			:= GetRpoRelease() >= "R5"     													// Indica se o release e 11.5
	Local nPosProvEnt	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PROVENT"})					// Posicao da provincia de entrega //ANDERSON
	Local cBkpProvEnt	:= ""	 											 							// Backup do campo provincia de entrega
	Local nTotalCF		:= 0                                                            		       	// Total do Cupom Fiscal (Diferente do total da Nota Fiscal)
	Local cEntrega		:= ""																			// Tipo de entrega do item
	Local nPosEntrega	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ENTREGA"})][2]		// Posicao da Unidade de Medida
	Local lExLegSP10	:= FindFunction("Lj950SP10OK")													// Verifica a existencia da funcao que valida a legislacao paulista que limita o cupom fiscal em 10.000,00
	Local lExTotalCF	:= FindFunction("LJXTotalCF")													// Verifica a existencia da funcao que calcula o total do cupom fiscal
	Local lAutoExA		:= IsBlind()																	// Verifica se a rotina sera executada via execauto ou nao
	Local lRetaPaf		:= LjNfPafEcf(SM0->M0_CGC) .AND. !lMvljpdvpa 									// Sinaliza se utiliza Retaguarda com PAF-ECF, para realizar o tratamento da concomitancia
	Local lIsRecCel 	:= .F.																			// Indica que eh produto "Recarga de Celular"
	Local nVlrRecarg 	:= 0																			// Valor da "Recarga de Celular" ou "Recarga de Cartao Presente" (Gift Card)
	Local lGE			:= FindFunction("LjUP104OK") .AND. LjUP104OK()									// Validação do Conceito Garantia Estendida 
	Local cMV_CLIPAD	:= SuperGetMV("MV_CLIPAD")														// Cliente Padrão
	Local cMV_LOJAPAD	:= SuperGetMV("MV_LOJAPAD") 													// Loja PAdrão
	Local cMvLjTGar	    := SuperGetMV("MV_LJTPGAR",,"GE") 												// Define se é tipo GE  
	Local cMsnErro		:= ""																			//	Ponto de entrada pra habilitar a Garantia Estendida Default .T.  
	Local lLJ7081		:= IIF(ExistBlock("LJ7081"), Execblock( "LJ7081", .F., .F. ), .T.)     		// Garantia Estendida	Ponto de entrada pra habilitar a Garantia Estendida Default .T.  
	Local cMvLjTSF	    := SuperGetMV("MV_LJTPSF",,"SF") 												// Define se é tipo SF
	Local nItGarant		:= 0																			// Produto possui garantia 
	Local lIsRecCP 		:= .F.																			// Indica que eh produto "Recarga de Cartao Presente (Gift Card)"
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Relase 11.5 - Cartao Fidelidade³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local lLjcFid 		:= SuperGetMv("MV_LJCFID",,.F.) .AND. CrdxInt().AND. lR5					// Indica se a recarga de cartao fidelidade esta ativa
	Local nX			:= 0 																		// Contador
	Local nTotProd		:= 0																		// Total de produtos nao deletados no aCols
	Local nPosNumcFi 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_NUMCFID"})			// Posicao do Numero do cartao fidelidade
	Local nPosDtsdFi 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DTSDFID"})			// Posicao da data de validade do saldo inserido 
	Local nPosVlrcFi 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VLRCFID"})			// Posicao do valor do saldo inserido
	
	Local lFTVD7041		:= ExistBlock("FTVD7041")												// Verifica a existencia do P.E.
	Local lFTVD7036		:= ExistBlock("FTVD7036")												// Ponto de entrada antes da impressao concomitante
	Local lTFTVD7036	:= ExistTemplate( "FTVD7036" )											// Ponto de entrada antes da impressao concomitante
	Local nPosCodBar	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_CODBAR"})			// Guarda codigo de barras do produto para otimizar geracao da NFce
	Local cCodBar 		:= ""																	// Armazena cod. de barras do produto
	Local lIntSynt 	 	:= SuperGetMV("MV_LJSYNT",,"0") == "1"	 // Informa se a integracao Synthesis esta ativa
	
	//usada na Integracao Protheus x SIAC
	Local lScCsPreco	:= .F.																	// Indica se a consulta de preco via WS esta habilitada
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Variaveis para uso Template Otica³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local cTipoIt		:= ""										// Verifica o tipo do produto
	Local lMargem       := GetRpoRelease("R7") .AND. SuperGetMV("MV_LJMARGE",,.F.) 				// Valida se considera a margem minIma no venda assistida.
	Local nPosClasFis	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_CLASFIS"}) // Classificacao Fiscal do Produto
	Local lLJ8099		:= ExistBlock("LJ8099")   // Garantia Estendida	Ponto de entrada pra habilitar a Garantia Estendida Default .T.  
	
	Local nPosPRedIc	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PREDIC"}) // %Redução da Base do ICMS 
	
	Local lVPNewRegra 	:= FindFunction("Lj7VPNew") .And. Lj7VPNew() //Verifica se utiliza as novas modificacoes da implementacao de Vale Presente, para imprimir o comprovante nao fiscal na venda de vale presente.
	Local lGiftCard 	:= FindFunction("Lj7CP_OK") .And. Lj7CP_OK() //Verifica se permite utilizar a implementacao de Cartao Presente (Gift Card)
	Local lSFinanc		:= AliasIndic("MG8") .AND. SuperGetMV("MV_LJCSF",,.F.)	// Valida implementação do servico financeiro
	Local lVincServ		:= IIF(FindFunction("Lj7GetServ"), Lj7GetServ(), .F.)
	Local lNT2015002	:= FindFunction("NT2015002")	//verifica se a funcao provisoria da NT2015/002 esta compilada (LOJNFCE)
	
	Local lUseSat		:= IIF(FindFunction("LjUseSat"),LjUseSat(),.F.)	//Usa Sat
	
	Static lFtvdVer12		:= FindFunction("LjFTvd") .AND. LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
	Static cNomeProg		:= Iif(lFtvdVer12,"FATA701","LOJA701") //Nome da Rotina
	
	Default lValid		:= .T.																		// Indica se a chamada foi a partir de um X3_VALID
	Default lBonus      := .F.                                                                  	// Indica se a Bonus
	Default lLjGrid		:= .F.																		// Indica se foi digitado do grid
	Default lGarantia	:= .T.    																	// Indica se é Garantia ou Sugestão de venda
	Default lSugestao	:= .T.																		// Mostra a tela de sugestao de venda
	Default nKit        :=  0         									                            // Controla a chamada a função Lj7Prod
	Default cProdKit    := ""                                                                       // Atribuirá seu conteúdo a variavel cProduto, para que o sistema possa trabalhar o produto da acols do Kit
	Default nItemKit    := 0                                                                        // Controla a posicao do produto no aCols
	Default	lItemKit	:= .F.																		// Controla chamada da rotina LjInfoKit apenas para produto pai
	
	If !Empty(cProdKit)
		cProduto := AllTrim(cProdKit)
	Endif
	
	If !Empty(nItemKit)
		nItem := nItemKit
	Endif
	
	//indica se o Protheus pode consultar o preco de um produto no SIAC Store via WS
	lScCsPreco := SuperGetMV("MV_SCINTEG",,.F.) .AND. SuperGetMV("MV_SCCSPRC",,.F.) .AND. FindFunction("LJSCCSPRC")
	
	//Para utilizar DAV eh necessario informar o CPF/CNPJ do cliente
	// Se vier de lAutoexec, não é necessário checar DAV por causa da importação do uMov.me para o Sigaloja
	If !lMvljpdvpa .AND. LjNfPafEcf(SM0->M0_CGC) .AND. !SuperGetMV("MV_LJPRVEN",,.F.) .AND. Empty(SA1->A1_CGC) .AND. !lFtvdVer12 .AND. (Type("lAutoExec") <> "L" .OR. !lAutoExec)
		MsgStop( /*STR0081*/"Conforme previsto no Resquisito VI(ATO COTEPE/ICMS 0608):" + Chr(13) + /*STR0080*/"Para realizar um DAV é necessário informar cliente com CPF/CNPJ")	//"Conforme previsto no Resquisito VI(ATO COTEPE/ICMS 0608):"  //"Para realizar um DAV é necessário informar cliente com CPF/CNPJ"
		lRet := .F.
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o tipo do produto inserido é OG e  ³
	//³ chama a função do Template Otica para incluir  ³
	//³ no aCols o conjunto Armação e Lentes direita e ³
	//³ esquerda.									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	              
	If HasTemplate("OTC") 
		
		SB1->(dbSetorder(1))
		SB1->(dbSeek(xFilial("SB1")+M->LR_PRODUTO))
		
		cTipoIt := SB1->B1_TIPO    
		
		If cTipoIt == "OG"  
			T_ConjGlas(aCols)
		EndIf				 
				 
	EndIf 
	
	// NFC-e: Apresenta uma mensagem ao usuário, informando que se for ambiente de homologação,
	// a Descrição do primeiro item da Nota Fiscal (tag:xProd) deve ser informada como 
	// “NOTA FISCAL EMITIDA EM AMBIENTE DE HOMOLOGACAO - SEM VALOR FISCAL”
	If lEmitNFCe .AND. lNT2015002 .AND. n == 1 .And. !lUseSat
		NT2015002(Nil, M->LR_PRODUTO)	
	EndIf
	
	//Verifica se foi informado o codigo do produto
	If "LR_PRODUTO" $ ReadVar()
		If Empty(&(ReadVar()))
			lRet := .F.
		EndIf
	EndIf
	  
	If lRet
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria proteção para campos incluidos no fonte loja701³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lGE
			If Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_NSERIE"}) > 0 
			    nSerie	    := aPosCpo[Ascan(aHeader,{|x| Alltrim(Upper(x[2])) == "LR_NSERIE"})][2]	// Posicao do valor de série   
			EndIf
			
			If Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_GARANT"}) > 0
				nGarant	    := aPosCpo[Ascan(aHeader,{|x| Alltrim(Upper(x[2])) == "LR_GARANT"})][2]	// Posicao do valor da garantia  
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Funcao verifica se e versao 11.5, caso seja               ³
		//³Executa Funcao Lj7VldUs que autoriza modificacoes         ³
		//³nas celulas dos itens ja lancados por vendedores/usuarios.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lR5
			If FindFunction("Lj7VldUs") .AND. !Lj7VldUs()
		   		lRet := .F.
				Return lRet
			EndIf	
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso a Consulta Multimida estaja ativada nao vai usar ³
		//³essa funcao.                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If HasTemplate("DRO")
			If T_DroSendPCM() 
				lPcMult :=  ExistCPO("SB1",M->LR_PRODUTO,1)
				Return (lPcMult)
			EndIf
		Endif	
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Funcao utilizada para verificar a ultima versao dos fontes      ³
		//³ SIGACUS.PRW, SIGACUSA.PRX e SIGACUSB.PRX, aplicados no rpo do   |
		//| cliente, assim verificando a necessidade de uma atualizacao     |
		//| nestes fontes. NAO REMOVER !!!							        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !(FindFunction("SIGACUS_V") .AND. SIGACUS_V() >= 20050512)
		    Final("Atualizar SIGACUS.PRW !!!")
		Endif
		
		If !(FindFunction("SIGACUSA_V") .AND. SIGACUSA_V() >= 20050512)
		    Final("Atualizar SIGACUSA.PRX !!!")
		Endif
		
		If !(FindFunction("SIGACUSB_V") .AND. SIGACUSB_V() >= 20050512)
		    Final("Atualizar SIGACUSB.PRX !!!")
		Endif
		
		If nPosProvEnt > 0
			nPosProvEnt	:= aPosCpo[nPosProvEnt][2]		// Posicao da provincia de entrega
		EndIf               
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Sendo o primeiro item digitado, busca para saber se existem³
		//³tabelas de preco ativadas                                  ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aCols) == 1 .AND. lCenVenda .AND. FindFunction("LjxFindTab")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Limpa o array estatico do LOJA701E³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			LjxClFindT()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busca no LOJA701E se existem tabelas de preco ativa³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			LjxFindTab(M->LQ_CLIENTE, M->LQ_LOJA)
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existe reserva para o produto. Se existir nao  	 ³
		//³ deixar fazer altaracao                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( "LR_" $ ReadVar() .And. &(ReadVar()) != GDFieldGet(Replace(ReadVar(),"M->","")) ) .And. ;
			((Len(aColsDet) >= n .AND. !Empty(aColsDet[n][nPosDtReserva])) .AND. !lFtvdVer12 .OR. ;
			(Len(aColsDet) >= n .AND. !Empty(aColsDet[n][nPosDtReserva])) .AND. !lAutoExA .AND. lFtvdVer12) .AND. !lIntSynt
			If lAutoExA  .AND. !lFtvdVer12   
				Conout(/*STR0001*/"Aviso" + "  " +  /*STR0002*/"Já existe uma reserva para esse produto, não é possível ser alterado.")
			Else
				Aviso(/*STR0001*/"Aviso", /*STR0002*/"Já existe uma reserva para esse produto, não é possível ser alterado.", {/*STR0003*/"Ok"} ) //"Aviso"###"Já existe uma reserva para esse produto, não é possível ser alterado."###"Ok"
			EndIf
			lRet := .F.
			
		Else
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Confirma a existencia do codigo digitado ja efetuando busca	 ³
			//³ pelo codigo de barras										 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If "LR_PRODUTO" $ ReadVar() .AND. nKit == 0
				
				cAuxProd := StrZero(Val(aCols[n][nPosProd]),15)
				
				lExist   := If(!Empty(Posicione("SB1",1,xFilial("SB1") + cAuxProd,"B1_DESC")),.T.,.F.)
				
				If lExist 	
					cProduto := cAuxProd
				Else
					cProduto := &(ReadVar())
				EndIf
				
				 M->LR_VDMOST :=  "N"
				
				//Zera descontos em qualquer alteracao no campo LR_PRODUTO somente se a venda não for concomitante
				//pois o desconto da venda concomitante é lançado antes do produto
				If !SuperGetMV("MV_LJVACC", ,.F.)
					aCols[n][nPosDesc]		:= 0
					aCols[n][nPosValDesc]	:= 0
				EndIf
			Else
				cProduto := aCols[n][nPosProd]
			Endif
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se contém código de lista de presentes,  ³
			//³ não trazer sugestão de vendas            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (nPosLPre > 0)
				nAux := aPosCpo[nPosLPre][2]
				If (nAux > 0)
					If( Len( AllTrim( aCols[n][nAux] ) ) ) > 0
						lSuVend := .F.
					EndIf
				EndIf	
			EndIf
		 	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Preenche com 1 caso a quantidade seja zero³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aCols[n][nPosQuant] == 0
				aCols[n][nPosQuant] := 1
			Endif
		
			If cPaisLoc == "ARG" .AND. nPosProvEnt > 0
				aCols[n][nPosProvEnt] := M->LQ_PROVENT
				MaFisAlt("IT_PROVENT", aCols[n][nPosProvEnt], n)
			EndIf
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Relase 11.5 - Cartao Fidelidade³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
			If lLjcFid
				//Verifica se o produto informado e de recarga de cartao fidelidade	
				If LaFunhProd(cProduto) 
					// Verifica se ja possui algum produto informado e nao deletado no aCols.		
					If Len(aCols) > 1
						//Contar o total de produtos nao deletados (desconsiderando a ultima linha)
						For nX:=1 To Len(aCols)									
							If !aCols[nX][Len(aCols[nX])] .AND. nX <> Len(aCols)	
								nTotProd += 1
							EndIf
						Next nX
						
						//Se houver produto nao deletado, nao sera possivel incluir produto de recarga
						If nTotProd > 0 		
							If !lAutoExA		
								Alert(/*STR0061*/"Este orçamento ja possui outros produtos. O produto para recarga de cartao fidelidade não poderá ser utilizado")//"Este orçamento ja possui outros produtos. O produto para recarga de cartao fidelidade não poderá ser utilizado"				
							Else
								Conout(/*STR0061*/"Este orçamento ja possui outros produtos. O produto para recarga de cartao fidelidade não poderá ser utilizado")//"Este orçamento ja possui outros produtos. O produto para recarga de cartao fidelidade não poderá ser utilizado"				
							EndIf
							lRet := .F.
							Return lRet						
						Else
							//Se os dados informados na tela de recarga nao forem validos
							If !LaFunhInc ()															
								lRet := .F.
								Return lRet 
							Else
								//Atualizar vallor do produto com o valor da recarga
								aCols[n][nPosVlUnit]	:= LaFunhGet(3)
								aCols[n][nPosVlrItem]	:= LaFunhGet(3)
							EndIf					
						EndIf				    					
					Else
						//Se os dados informados na tela de recarga nao forem validos
						If !LaFunhInc ()									
							lRet := .F.
							Return lRet			
						Else
							//Atualizar vallor do produto com o valor da recarga
							aCols[n][nPosVlUnit]	:= LaFunhGet(3)
							aCols[n][nPosVlrItem]	:= LaFunhGet(3)
						EndIf					 
					EndIf		
				Else
					//Contar o total de produtos nao deletados (desconsiderando a ultima linha)
					For nX:=1 To Len(aCols)									
						If !aCols[nX][Len(aCols[nX])] .AND. nX <> Len(aCols)	.AND. LaFunhProd(aCols[nX][nPosProd])
							nTotProd += 1
						EndIf
					Next nX
					
					If nTotProd > 0 		
						Alert (/*STR0062*/"Este orçamento ja possui um produto para recarga de cartao fidelidade.Nenhum outro produto poderá ser utilizado.")//"Este orçamento ja possui um produto para recarga de cartao fidelidade.Nenhum outro produto poderá ser utilizado."				
						lRet := .F.
						Return lRet						
					EndIf
					
				EndIf					
			Else
				If LaFunhProd(cProduto) 
					MsgStop (/*STR0063*/"Este produto é utilizado para recarga de cartao fidelidade e não poderá ser utilizado enquanto esta funcionalidade estiver desabilitada.")//"Este produto é utilizado para recarga de cartao fidelidade e não poderá ser utilizado enquanto esta funcionalidade estiver desabilitada."	
					lRet := .F.
					Return lRet
				EndIf
			EndIf
	
			If lRet .AND. nKit == 0 .AND. GetRpoRelease("R7") //só executa a chamada uma unica vez 
				If	Posicione('SB1',1,xFilial('MEU')+AllTrim(cProduto),'B1_TIPO') == "KT"  
					LjKitProd(@aCols,nItem,cProduto, aCols[n][nPosQuant])						
				    Return lRet	
				Endif	
	        EndIf
	
			lRet := LjSB1SLK( @cProduto, @aCols[n][nPosQuant], .F., @cCodBar ) //Faz a pesquisa do codigo de produto digitado
			//Verifica se o produto tipo garantia estendida está sendo lançado no orcamento sem um produto com cobertura de garantia
			If lRet .AND. lGarantia .AND. lGE .AND. RTrim(SB1->B1_TIPO) ==  RTrim(cMvLjTGar) .AND. nGarant > 0
				//Verifica se o produto está associado 
				nItGarant := Ascan(aCols, {|x| x[nGarant] == aCols[n][nPosProd]})
				
				If n == 1 .OR. nItGarant == 0
					If isBlind()
						ConOut( /*STR0001*/"anteção" + " "  + /*STR0085*/"A venda de um produto tipo garantia estendida é permitida somente amarrada a um produto com cobertura.") //"A venda de um produto tipo garantia estendida é permitida somente amarrada a um produto com cobertura."
					Else
						Aviso( /*STR0001*/"anteção"  ,/*STR0085*/"A venda de um produto tipo garantia estendida é permitida somente amarrada a um produto com cobertura.", {/*STR0003*/"Ok"}) //"anteção" + "A venda de um produto tipo garantia estendida é permitida somente amarrada a um produto com cobertura.""#" + "ok"
					EndIf 
					lRet := .F. 
				EndIf
			ElseIf lRet .AND. lSFinanc .AND. RTrim(SB1->B1_TIPO) == RTrim(cMvLjTSF)			
				MG8->(dbSetOrder(2))
				
				//Valida se possui cadastro de servico financeiro vigente
				If MG8->(dbSeek(xFilial("MG8") + cProduto)) .AND. (dDataBase >= MG8->MG8_INIVIG .AND. dDataBase <= MG8->MG8_FIMVIG)								
					If cMV_CLIPAD+cMV_LOJAPAD == M->LQ_CLIENTE+M->LQ_LOJA //Valida cliente padrao na Cxa01	venda				
						Aviso(/*STR0001*/"Aviso", /*STR0104*/"Venda de Serviço financeiro não permitida para Cliente padrão", {/*STR0003*/"Ok"}) //#"Aviso" ##"Venda de Serviço financeiro não permitida para Cliente padrão" ###"Ok"
						Return(.F.)
					ElseIf MG8->MG8_TPXPRD == "1" //Valida vinculo do produto
						If Empty(aCols[n][nPosPrdCob]) 					
							Aviso( /*STR0001*/"Aviso",/*STR0105*/"A venda de um produto tipo serviço vinculado deve ser feita na tela sugestão do produto cobertura.", {/*STR0003*/"Ok"}) //#"Aviso" ##"A venda de um produto tipo serviço vinculado deve ser feita na tela sugestão do produto cobertura." ###"Ok"
							Return(.F.)
						EndIf			
					EndIf
				Else
					Aviso(/*STR0001*/"Aviso", /*STR0106*/"Produto Serviço deve possuir cadastro vigente em Serviços Financeiros", {/*STR0003*/"Ok"}) //#"Aviso" ##"Produto Serviço deve possuir cadastro vigente em Serviços Financeiros" ###"Ok"
					Return(.F.)	
				EndIf																																
			ElseIf lRet .AND. lSFinanc .AND. cMV_CLIPAD+cMV_LOJAPAD == M->LQ_CLIENTE+M->LQ_LOJA .AND. lVincServ 
				//Verifica se produto possui vinculo com servicos financeiros		
				MBF->(dbSetOrder(4))
					
				//Valida se possui cadastro de servico financeiro vigente
				If MBF->(dbSeek(xFilial("MBF") + cProduto)) .AND. (dDataBase >= MBF->MBF_DTINI .AND. dDataBase <= MBF->MBF_DTFIM) 										
					MsgAlert(/*STR0107*/"Este ítem possui vínculo com Serviços Financeiros, verifique se deseja mesmo utilizar o Cliente Padrão") //#"Este ítem possui vínculo com Serviços Financeiros, verifique se deseja mesmo utilizar o Cliente Padrão"
					
					If FindFunction("Lj7SetServ")
						Lj7SetServ(.F.)
					EndIf					
				EndIf	
			EndIf  
	        
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Vale Presente³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRet .And. SB1->( FieldPos( "B1_VALEPRE" ) ) > 0 .And. lVPNewRegra
				If !Empty(Lj7VPYesNo())
					If Lj7VPIsPrd(cProduto)
						If Lj7VPYesNo() == "N"
							MsgStop(/*STR0096*/"Esta venda já possui outros produtos. O Vale Presente somente pode ser vendido individualmente.") //"Esta venda já possui outros produtos. O Vale Presente somente pode ser vendido individualmente."
							lRet := .F.
							Return lRet
						EndIf
					Else
						If Lj7VPYesNo() == "S"
							MsgStop(/*STR0097*/"Esta venda possui Vale Presente. Outros produtos não podem ser adicionados nesta mesma venda.") //"Esta venda possui Vale Presente. Outros produtos não podem ser adicionados nesta mesma venda."
							lRet := .F.
							Return lRet
						EndIf
					EndIf
				EndIf
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Cartao Presente (Gift Card)  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRet .And. lGiftCard
				lIsRecCP := Lj7CP_Prod(cProduto) //Verifica se o produto informado eh "Recarga de Cartao Presente (Gift Card)"
				If !Empty(Lj7CPGetSt())
					If lIsRecCP
						If Lj7CPGetSt() == "N"
							MsgStop(/*STR0101*/"Esta venda já possui outros produtos. A Recarga de Cartão Presente somente pode ser vendida individualmente.") //"Esta venda já possui outros produtos. A Recarga de Cartão Presente somente pode ser vendida individualmente."
							lRet := .F.
							Return lRet
						EndIf
					Else
						If Lj7CPGetSt() == "S"
							MsgStop(/*STR0102*/"Esta venda possui Recarga de Cartão Presente. Outros produtos não podem ser adicionados nesta mesma venda.") //"Esta venda possui Recarga de Cartão Presente. Outros produtos não podem ser adicionados nesta mesma venda."
							lRet := .F.
							Return lRet
						EndIf
					EndIf
				EndIf
			EndIf
			
			If lRet
				//Tratamento para produto "Recarga de Celular"
				If FindFunction("Lj7RCPrdRC")
					lIsRecCel := Lj7RCPrdRC(cProduto) //Verifica se o produto informado eh "Recarga de Celular"
				EndIf
				
				//Tratamento para produto "Recarga de Cartao Presente (Gift Card)"
				If lGiftCard
					If !lIsRecCP
						If "LR_PRODUTO" $ ReadVar() .AND. !Empty(GDFieldGet("LR_PRODUTO")) .And. GDFieldGet("LR_PRODUTO") <> &(ReadVar())
							If Lj7CP_Prod(GDFieldGet("LR_PRODUTO")) //Verifica se o produto informado anteriormente no mesmo item eh "Recarga de Cartao Presente (Gift Card)"
								MsgAlert(/*STR0092*/"Não é permitido alterar este produto, pois é um item de Recarga de Cartão Presente.") //"Não é permitido alterar este produto, pois é um item de Recarga de Cartão Presente."
								lRet := .F.
							EndIf
						EndIf
					EndIf
				EndIf
				
				If lRet 
					//Tratamento para produto "Recarga de Celular"
					If lIsRecCel
						
						If Lj7RCAtiva() //Verifica se a configuracao de "Recarga de Celular" estah ativa
			
							If !Lj7RCStatus()
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Tratamento para a recarga de celulares ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
								If !Lj7RCRecCel( @nVlrRecarg, cProduto, .F., (Empty(aCols[n][nPosProd]) .And. Len(aCols)==1) )
									lRet := .F.
								Else
									nPrecoTab := nVlrRecarg
									Lj7RCStatus(.T.) //Atualiza o status para "Recarga Efetuada"
									
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³Acerta informacoes do aCols³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									aCols[n][nPosQuant] := 1 	//Quantidade deve ser 1
									
									If nPosEntrega > 0
										If ValType(aCols[n][nPosEntrega]) == "C"
											aCols[n][nPosEntrega] := " " //Limpa o campo LR_ENTREGA
										EndIf
									EndIf
								EndIf
							ElseIf Lj7RCStatus()
					       		MsgAlert(/*STR0082*/"Não é possível efetuar mais de uma Recarga de Celular na mesma venda.") //"Não é possível efetuar mais de uma Recarga de Celular na mesma venda."
								lRet := .F.
							Endif
						Else
							MsgAlert(/*STR0083*/"Este produto somente poderá ser selecionado, quando a funcionalidade de Recarga de Celular estiver devidamente configurada no sistema.") //"Este produto somente poderá ser selecionado, quando a funcionalidade de Recarga de Celular estiver devidamente configurada no sistema."
							lRet := .F.
						EndIf
						
					ElseIf lIsRecCP
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Tratamento para produto "Recarga de Cartao Presente (Gift Card)"³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If Lj7CP_Ativ() //Verifica se a configuracao de "Recarga de Cartao Presente (Gift Card)" estah ativa
							
							//Se o produto for o mesmo e for "Recarga de Cartao Presente (Gift Card)", aborta para nao fazer a recarga novamente em duplicidade
							If "LR_PRODUTO" $ ReadVar() .AND. GDFieldGet("LR_PRODUTO") == &(ReadVar())
								lRet := .F.
							Else
							
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Tratamento para a "Recarga de Cartao Presente (Gift Card)" |
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Lj7CP_Rcg( M->LQ_NUM, @nVlrRecarg, cProduto, .F., (Empty(aCols[n][nPosProd]) .And. Len(aCols)==1) )
									lRet := .F.
								Else
									nPrecoTab := nVlrRecarg
									Lj7CPSetSt(1) //Atualiza o status para indicar que eh "Recarga de Cartao Presente (GIFT CARD)"
									
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³Acerta informacoes do aCols³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									aCols[n][nPosQuant] := 1 	//Quantidade deve ser 1
									
									If nPosEntrega > 0
										If ValType(aCols[n][nPosEntrega]) == "C"
											aCols[n][nPosEntrega] := " " //Limpa o campo LR_ENTREGA
										EndIf
									EndIf
								EndIf
							
							EndIf
							
						Else
							MsgAlert(/*STR0103*/"Este produto somente poderá ser selecionado, quando a funcionalidade de Recarga de Cartao Presente estiver devidamente configurada no sistema.") //"Este produto somente poderá ser selecionado, quando a funcionalidade de Recarga de Cartao Presente estiver devidamente configurada no sistema."
							lRet := .F.
						EndIf
					Else
						
						lRet := XLjxeValPre(@nPrecoTab	, cProduto, M->LQ_CLIENTE, M->LQ_LOJA	,;
											nMoedaCor 	, aCols[n][nPosQuant])

						//Caso tenha passado o preco do produto (campo LR_PRCTAB), entao desconsidera o preco do produto que foi encontrado e considera o preco enviado no array da rotina automatica
						If lRet .AND. ( lIntSynt .Or. ( Type("lAutoExec") == "L" .And. lAutoExec ) )
							If nPosPrcTab > 0 .And. Len(aColsDet) >= n .AND. !Empty(aColsDet[n][nPosPrcTab])
								nPrecoTab := aColsDet[n][nPosPrcTab] //Para Rotina automatica, considera o preco enviado no campo LR_PRCTAB
							EndIf
						EndIf
											
					EndIf
				EndIf
			Else
				If Empty(cProduto)
					MsgAlert(/*STR0056*/"Digite o código do Produto!") //"Digite o código do Produto!"
				Else			
					MsgAlert(/*STR0057*/"Produto não encontrado!") //"Produto não encontrado!"
				EndIF
			EndIf  
		
			//#VFE
			If lLjVfe
				//Verifica se a funcionalidade de Venda Fora do estado esta ativa.
				//Acessa a tabela SB0 e busca a informação de Retira, Retira Posterior ou Entraga no campo B0_ENTREGA
				//Alimenta o aCols caso o campo não esteja vazio.
				DbSelectArea('SB0')
				DbSetOrder(1)			
				If DbSeek(xFilial('SB0')+SB1->B1_COD)
					If !Empty(AllTrim(SB0->B0_ENTREGA))
						aCols[n][nPosEntrega] := SB0->B0_ENTREGA
					EndIf
				EndIf		
			EndIf
				
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Limitacao de 10.000,00 - Legislacao Paulista 	³                 
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lExTotalCF .AND. lExLegSP10 .AND. lRet
				If nPosEntrega > 0
					If ValType(aCols[n][nPosEntrega]) == "C"
						cEntrega := aCols[n][nPosEntrega]
					EndIf
				EndIf
				
				If !LjNFFimVd() .AND. LJXTpRetira(cEntrega)				  			// Se nao emitir Nota Fiscal e o produto for de Entrega = Retira ou Vazio
					nTotalCF := LJXTotalCF(n) + (nPrecoTab * aCols[n][nPosQuant])	// Obtem o total do Cupom Fiscal, considerando o item selecionado e a quantidade que ja estava no item
					lRet := Lj950SP10OK(nTotalCF, 2)								// Retona False / Sai da funcao
				EndIf	   
			EndIf	
			
		    // Nesses estados nao e permitido preco zerado.
			If lRet .AND. LjAnalisaLeg(2)[1]    
				//Verifica se tem Tab. de preco
				  if nPrecoTab == 0
					If !lAutoExA     
						LjMsgLeg(LjAnalisaLeg(2))
						Help( " ", 1, "NOPRECO" )
					Else
						Conout(/*STR0073*/"ATENCAO -->> PRODUTO SEM PRECO:  " +cProduto)		//"ATENCAO -->> PRODUTO SEM PRECO:  "
						Help( " ", 1, "Help",, /*STR0073*/"ATENCAO -->> PRODUTO SEM PRECO:  " +cProduto, 1, 0 )
					EndIf		
					lRet := .F.
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Deleta o item porque o produto nao tem preco. Na concomitancia ³
					//³ nao eh permitido produto sem preco                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lVAssConc
						aCols[n][nPosProd]   := Space(TamSX3("LR_PRODUTO")[1])
						aCols[n][nPosDescri] := Space(TamSX3("LR_DESCRI")[1])
						aCols[n][nPosQuant]  := 1
					Endif
			   	EndIf
			EndIf 
		
			If lRet			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se o produto for diferente do informado, 'reseta' a linha    ³
				//³ do aCols. Apenas quando nao for concomitancia                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lVAssConc
					If "LR_PRODUTO" $ ReadVar() .AND. gdFieldGet("LR_PRODUTO") <> &(ReadVar())
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Se for alterar um produto que ja existe no aCols faz o Backup , ³
						//³ pois se no caso desse produto nao for valido reestaurar o aCols ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					    If !Empty(gdFieldGet("LR_PRODUTO"))
							If lGE 
								cMsnErro := "Produto nao Pode ser alterado devido a Garantia Estendida. Exclua o Produto Vendido e Inclua novamente"/*STR0087*/ //Produto nao Pode ser alterado devido a Garantia Estendida. Exclua o Produto Vendido e Inclua novamente
								If !Empty(aCols[n][nGarant])    
									lRet := .F.
								Else
									SB1->(DbSeek(xFilial("SB1")+aCols[n][nPosProd])) 
									If SB1->B1_TIPO == cMvLjTGar 
										lRet := .F.
									Else
										SB1->(DbSeek(xFilial("SB1")+cProduto)) 
										If SB1->B1_TIPO==cMvLjTGar 
											lRet := .F.
										ElseIf SB1->B1_GARANT == "1" .And. Len(aCols)> n
											lRet := .F.
											cMsnErro := "Produto nao Incluido devido a Garantia Estendida. Inclua na Ultima Linha"/*STR0089*/ //Produto nao Incluido devido a Garantia Estendida. Inclua na Ultima Linha
										EndIf
									EndIf
								EndIf
							EndIf
	
							If !lRet
								MsgAlert(cMsnErro) ////Produto nao Incluido devido a Garantia Estendida. Inclua na Ultima Linha;
								cProduto := aCols[n][nPosProd] 
								nPrecoTab := aCols[n][nPosVlUnit]	
								M->LR_PRODUTO := cProduto
							Else
					 	   		nBkpQuant		:=	aCols[n][nPosQuant] 	
						   		nBkpVlruni		:=	aCols[n][nPosVlUnit]	
						  		cBkpDescri 		:=	aCols[n][nPosDescri]		
						  		nBkpDesc 		:=	aCols[n][nPosDesc]		
						  		nBkpValDesc		:=	aCols[n][nPosValDesc]
								cBkpUm	  		:=	aCols[n][nPosUM]
								cBkpProd   		:=	aCols[n][nPosProd]
								nBkpVlItem		:=	aCols[n][nPosVlrItem]
	
								If cPaisLoc == "ARG" .AND. nPosProvEnt > 0
									cBkpProvEnt		:=	aCols[n][nPosProvEnt]
								EndIf
							EndIf
		
				   		EndIf
						
						If lRet .AND. nKit == 0 
							aCols[n][nPosQuant] 	:= IIf(aCols[n][nPosQuant] == 0,1,aCols[n][nPosQuant])
							aCols[n][nPosVlUnit]	:= nPrecoTab
							aCols[n][nPosDesc]		:= 0
							aCols[n][nPosValDesc]	:= 0
			
					    	If lTrcMoeda .AND. !lCenVenda
							   nMoedaPrv := Max(&("SB0->B0_MOEDA" + Lj7DefTab()),1)
							   aCols[n][nPosVlUnit]	:= Round(xMoeda(&("SB0->B0_PRV" + Lj7DefTab()),nMoedaPrv,nMoedaCor,dDataBase,nDecimais+1,,nTxMoeda),nDecimais)
							EndIf
						EndIf
					EndIf
				EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o codigo do produto no aCols                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRet
					aCols[n][nPosProd] := cProduto
		        EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se permite vender com estoque negativo. Se a venda  ³
				//³ assistida estiver concomitante, nao deixara registrar o item ³
				//³ sem estoque.										         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRet .AND. !lEstNeg
					If Len(aColsDet) >= n 
						If ValType(aColsDet[n][nPosDtLocal]) == "U"
							cLocal := RetFldProd(SB1->B1_COD, "B1_LOCPAD")
							aColsDet[n][nPosDtLocal] := cLocal
						Else			
							cLocal := aColsDet[n][nPosDtLocal]
						EndIf	
					Else
						cLocal := RetFldProd(SB1->B1_COD, "B1_LOCPAD")
					Endif
		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Chamada do Ponto de Entrada para personalizacao do almoxarifado da venda ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lLJ7041 .AND. !lFtvdVer12
						xLocal := Execblock( "LJ7041", .F., .F., { cLocal, aColsDet } )
						If ValType(xLocal) == "C" .AND. !Empty(xlocal)
							cLocal := xLocal
							
							If lAutoExA .AND. !Empty(xLocal)        
								Conout(/*STR0074*/"<<<<LJ7PROD CRIASB2" + "[" + Alltrim(aCols[n][nPosProd]) + Alltrim(xLocal) + "]")		//"<<<<LJ7PROD CRIASB2"
								criaSB2(aCols[n][nPosProd], xLocal)
							Endif								
						
						Endif
					Endif
		
					If lFTVD7041 .AND. lFtvdVer12
						xLocal := Execblock( "FTVD7041", .F., .F., { cLocal, aColsDet } )
						If ValType(xLocal) == "C" .AND. !Empty(xlocal)
							cLocal := xLocal
							If IsBlind() .AND. !Empty(xLocal)        
								Conout(/*STR0074*/"<<<<LJ7PROD CRIASB2" + "[" + Alltrim(aCols[n][nPosProd]) + Alltrim(xLocal) + "]")		//"<<<<LJ7PROD CRIASB2"
								criaSB2(aCols[n][nPosProd], xLocal)
							Endif						
						Endif
					Endif
					
					lValEst := Lj7VerEst( aCols[n][nPosProd], cLocal, aCols[n][nPosQuant], .T. )
				    If !lValEst .AND. SuperGetMV("MV_LJVACC", ,.F.)
				    	lRet := .F.
				    EndIf
				Endif
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Acerta as colunas da aCols                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRet
					If Empty( cProduto )
						cProduto := IIf(lValid, &(ReadVar()), M->LR_PRODUTO)
					EndIf
					aCols[n][nPosProd]   := cProduto       
		
					If cPaisLoc == "ARG" .AND. nPosProvEnt > 0
						aCols[n][nPosProvEnt]   := M->LQ_PROVENT
					EndIf
		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³SIGAPHOTO - Apenas atualiza a descricao do produto se nao vier, para nao subistituir quando for envelope.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nModulo == 72 
						If Empty(aCols[n][nPosDescri])
							aCols[n][nPosDescri] := SB1->B1_DESC
						EndIf
					Else
						If nPosPrdCob > 0
							If Empty(aCols[n][nPosPrdCob])
								aCols[n][nPosDescri] := SB1->B1_DESC
							Else
								aCols[n][nPosDescri] :=	cProduto												
							EndIf
						Else
							aCols[n][nPosDescri] := SB1->B1_DESC
						EndIf					
					EndIf	
					
					aCols[n][nPosUM]     := SB1->B1_UM
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ajusta a quantidade sempre para valor default "1". 			 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aCols[n][nPosQuant] == 0
					   aCols[n][nPosQuant] :=  1
					EndIf   
		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³E necessario preencher a variavel de memoria para armazenar  ³
					//³o codigo do produto e nao o codigo de barras quando utilizado|
					//|leitor de codigo de barras.                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					M->LR_PRODUTO := cProduto
		
					If ExistBlock("LJ7061")
						xRet := ExecBlock("LJ7061",.F.,.F.)
						If ValType( xRet ) == "L"
							lRet := xRet
						EndIf
					EndIf
		
					If lRet
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Calcula o valor do item e verifica se ha desconto proveniente³
						//³das regras de desconto.                                      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lCenVenda .OR. lScCsPreco
							lRet := XLj7RegDesc(	cProduto				, lVAssConc	, @aCols		, @aHeader	,;
													aCols[n][nPosQuant]	, lBonus		, @lDescCab 	, lScCsPreco,;
													nKit)
						EndIf
	
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Calcula o valor do item 									 ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lRet .AND. !lCenVenda .AND. !lScCsPreco
						
							lRet := Lj7VlItem( 	Nil, Nil		, Nil		, lDescCab	,;
												Nil, Nil		, lIsRecCel	, nVlrRecarg,;
												Nil, lScCSPreco , nKit		, lIsRecCP	)
							
						Endif
					
						//Salva código de barras para utilizar na NFC-e
						If nPosCodBar > 0 .AND. !Empty(cCodBar) .AND. Len(aColsDet) >= n
							aColsDet[n][nPosCodBar] := cCodBar
						EndIf
												
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Ponto de entrada antes da impressao concomitante do item     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lLJ7036 .AND. lRet .AND. !lFtvdVer12
							lRetPE := ExecBlock( "LJ7036", .F., .F. )
							If ValType( lRetPE ) == "L"
								lRet := lRetPE
							EndIf
			
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Se nao aceitar a digitacao do produto, desconsidera o valor  ³
							//³ que foi informano na aCols                                   ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If !lRet
								aCols[n][nPosQuant]  := 0
								aCols[n][nPosVlUnit] := 0
								aCols[n][nPosDescri] := Space( TamSx3("LR_DESCRI")[1] )
							EndIf
						EndIf
					EndIf
					
					If lFTVD7036 .AND. lRet .AND. lFtvdVer12
						lRetPE := ExecBlock( "FTVD7036", .F., .F. )
						If ValType( lRetPE ) == "L"
							lRet := lRetPE
						EndIf
		
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Se nao aceitar a digitacao do produto, desconsidera o valor  ³
						//³ que foi informano na aCols                                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lRet
							aCols[n][nPosQuant]  := 0
							aCols[n][nPosVlUnit] := 0
							aCols[n][nPosDescri] := Space( TamSx3("LR_DESCRI")[1] )
						EndIf
					EndIf
					
					If lTLJ7036 .AND. lRet .AND. !lFtvdVer12
						lRetPE := ExecTemplate( "LJ7036", .F., .F.,{ M->LQ_NUM, M->LQ_DOC, M->LQ_SERIE, aCols[n][nItem],;
																	  cProduto	, aCols[n][nPosQuant] } )
		
						If ValType( lRetPE ) == "L"
							lRet := lRetPE 
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Se nao aceitar a digitacao do produto, desconsidera o valor  ³
						//³ que foi informano na aCols                                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lRet
							aCols[n][nPosQuant] 	:= 0
							aCols[n][nPosVlUnit]	:= 0
							aCols[n][nPosDescri]	:= Space( TamSx3("LR_DESCRI")[1] )
						EndIf
					EndIf  
					
					If lTFTVD7036 .AND. lRet .AND. lFtvdVer12
						lRetPE := ExecTemplate( "FTVD7036", .F., .F.,{ M->LQ_NUM, M->LQ_DOC, M->LQ_SERIE, aCols[n][nItem],;
																	  cProduto	, aCols[n][nPosQuant] } )
		
						If ValType( lRetPE ) == "L"
							lRet := lRetPE 
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Se nao aceitar a digitacao do produto, desconsidera o valor  ³
						//³ que foi informano na aCols                                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lRet
							aCols[n][nPosQuant] 	:= 0
							aCols[n][nPosVlUnit]	:= 0
							aCols[n][nPosDescri]	:= Space( TamSx3("LR_DESCRI")[1] )
						EndIf
					EndIf  
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Captura o codigo do vale presente, quando aplicavel			 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nPosValePre > 0 .AND. lRet  .AND. (len(aColsDet)>=n)
						If SB1->( FieldPos("B1_VALEPRE") > 0 .AND. B1_VALEPRE == "1" )
							cValePre := aColsDet[n][nPosValePre]
							lRet := LjGetVlPre( M->LR_PRODUTO, @cValePre, nPosValePre )			                                    
						       
							If lRet
								aColsDet[n][nPosValePre] := cValePre
								If lVPNewRegra
							        If !Empty( cValePre )
										Lj7VPVdaVP(1) //Indica que eh venda de "Vale Presente"
							        EndIf
								EndIf
							EndIf
						Else
							aColsDet[n][nPosValePre] := ""
							If lVPNewRegra
					        	Lj7VPVdaVP(2) //Indica que eh venda de produto que NAO eh "Vale Presente"
							EndIf
						EndIf
					EndIf
					
					//Gift Card
					If lRet .And. lGiftCard .And. !lIsRecCP
						Lj7CPSetSt(2) //Atualiza o status para indicar que NAO eh "Recarga de Cartao Presente (GIFT CARD) na venda"
					EndIf
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Relase 11.5 - Cartao Fidelidade                                    ³
					//³Caso a funcionalidade de recarga de cartao fidelidade estiver ativa³
					//³serao informadas nas respectivas colunas do aColsDet os dados	  ³
					//³da recarga informados na tela de inclusao de saldo (LOJXFUNH)      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ						
					If lLjcFid .AND. LaFunhProd(aCols[n][nPosProd])
						//Obter numero do cartao
						If nPosNumcFi  > 0
							aColsDet[n][nPosNumcFi]:= LaFunhGet(1)
						EndIf             				
						//Obter data de validade do saldo
						If nPosDtsdFi  > 0
							aColsDet[n][nPosDtsdFi]:= LaFunhGet(2)
						EndIf				
						//Obter valor do saldo
						If nPosVlrcFi  > 0
							aColsDet[n][nPosVlrcFi]:= LaFunhGet(3)
						EndIf
					EndIf					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Se a alteração for no LR_PRODUTO e o produto nao for valido , desconsidera o valor  ³
					//³ que foi informado no aCols e volta os campos com os dados do produto que era antes  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( "LR_PRODUTO" $ ReadVar() )
						If ( !lRet )
							aCols[n][nPosVlUnit]	:=	nBkpVlruni 	
							aCols[n][nPosQuant]		:=	nBkpQuant	
				 		   	aCols[n][nPosDescri]	:=	cBkpDescri	
				 		   	aCols[n][nPosDesc]		:=  nBkpDesc
							aCols[n][nPosValDesc]	:=  nBkpValDesc
							aCols[n][nPosUM]		:=  cBkpUm		
							aCols[n][nPosProd]    	:=  cBkpProd
							ACols[n][nPosVlrItem]	:=	nBkpVlItem
							
							If cPaisLoc == "ARG" .AND. nPosProvEnt > 0
								aCols[n][nPosProvEnt]  	:=  cBkpProvEnt
							EndIf
						Else
							//Se o produto alterado era produto de "Recarga de Celular", cancela transacao TEF referente a Recarga de Celular
							If FindFunction("Lj7RCAtiva") .And. Lj7RCAtiva() .And. !Empty(cBkpProd) .And. Lj7RCPrdRC(cBkpProd)
								If Lj7RCStatus()
									Lj7RCStatus(.F.) //Atualiza o status para "Recarga NAO efetuada"
									oTef:FinalTrn(0) //Envia o desfazimento da transacao TEF
								Endif
							ElseIf lGiftCard .And. Lj7CP_Ativ() .And. !Empty(cBkpProd) .And. Lj7CP_Prod(cBkpProd)
								//Se o produto alterado era produto de "Recarga de Cartao Presente (Gift Card)", cancela transacao TEF referente a Recarga
								If Lj7CPGetSt()=="S"
									Lj7CPSetSt(0) //Atualiza o status para "Recarga NAO efetuada"
									oTef:FinalTrn(0) //Envia o desfazimento da transacao TEF
								Endif
							EndIf
						EndIf
		            EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Venda assistida Concomitante. Faz a impressao do item no ECF ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//PAF2012: lVAssConc é ativada quando Retaguarda PAF-ECF para realizar diversas validacoes, porem, nao deve passar nesse ponto quando Retaguarda PAF-ECF.
					If !lEmitNFCe
						If lVAssConc .AND. lRet .AND. !lRetaPaf
			    			If !HasTemplate("DRO") .And. (!lVPNewRegra .Or. Empty(cValePre)) .And. (!lGiftCard .Or. Lj7CPGetSt()!="S")
			    				LJ7ImpItCC( n , , , , , ,n )
			    			EndIf
			    		ElseIf FindFunction("LJHOMTEF") .AND. LJMSSM0(SM0->M0_CGC)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Nao concomitante abre o cupom fiscal                         ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							nRet := IFStatus( nHdlECF, '5', @cRetorno )  
							If LjAnalisaLeg(42)[1]
								If !LjCxAberto(.T.,xNumCaixa())
									nRet := 1
								Else
									nRet := IFAbreCup(nHdlECF ,Nil ,Nil ,Nil ,.F. )
								EndIf
							
							Else
								nRet := IFAbreCup(nHdlECF,Nil ,Nil, Nil ,.F.)
							EndIf
						EndIf
					EndIf
		
				Endif
			EndIf
		Endif
		                                                             
		If (lRet) .AND. (((SB1->( FieldPos("B1_DESCONT")) > 0)  	.AND. (SB1->B1_DESCONT > 0))  .OR. lLJ8099)
	
			If lLJ8099   		
				M->LR_DESC	:= Execblock( "LJ8099", .F., .F. )
		 	Else
		 		M->LR_DESC	:= SB1->B1_DESCONT
		 	EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Valida se o desconto está correto³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		 	If  !lj7VlItem(3, Nil, Nil, Nil, Nil, M->LR_DESC, Nil, Nil, Nil, lScCsPreco)
				If !lAutoExA		     
					Alert(/*STR0071*/"Nao foi possivel realizar desconto cadastrado no produto e sera zerado.")    //"Nao foi possivel realizar desconto cadastrado no produto e sera zerado."
				Else
					Conout(/*STR0071*/"Nao foi possivel realizar desconto cadastrado no produto e sera zerado.")   //"Nao foi possivel realizar desconto cadastrado no produto e sera zerado."
				EndIf
			EndIf	
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria loker para carga nova³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet 	
			If( FindFunction("LOJA0051") .And. SuperGetMV( "MV_LJILVLO",,"2" ) == "1", oLJCLocker:GetLock( "LOJA701AILLock" ), .T. )
				If lSuVend .AND. ( nModulo == 12 .OR. nModulo == 23 .OR. nModulo == 72 .OR. lFtvdVer12 );
					.AND. lR5 .AND. FindFunction("Lj7SugVend")
					#IFDEF TOP 
		 				Lj7SugVend(Nil,lSugestao,cProduto) 
					#ENDIF
				EndIf
			EndIf     
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Valida se o produto tem Garantia Estendida e Chama a Função principal de Garantia LOJXFUNG³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAutoExec .AND. lRet .AND. lGE .AND. lGarantia .AND. (SB1->B1_GARANT == "1") .AND. FindFunction("Lj7GarEst") .And. lLJ7081    // Parametro lLJ7081 para Habilitar a Garantia Estendida 
				If (cMV_CLIPAD+cMV_LOJAPAD) <> (M->LQ_CLIENTE+M->LQ_LOJA) .And. Empty(aCols[n][nGarant]) 
				
					If Len(aCols) == n           
						Lj7GarEst(Nil,Nil,cProduto,aCols[n][nPosVlUnit])
					Else
				    	MsgAlert(/*STR0088*/"Não pode ser incluida a Garantia Estendida. Caso queira Incluir a Garantia Estendida, Exclua e Inclua novamente o Produto")//Não pode ser incluida a Garantia Estendida. Caso queira Incluir a Garantia Estendida, Exclua e Inclua novamente o Produto				
					EndIf	
				EndIf			
			ElseIf !lAutoExec .AND. lRet .AND. lSFinanc .AND. SB0->(FieldPos("B0_SERVFIN")) > 0 .AND. SB0->B0_SERVFIN = "1"
				If (cMV_CLIPAD+cMV_LOJAPAD) <> (M->LQ_CLIENTE+M->LQ_LOJA) 
					//Chama a Funcao principal para Servicos Financeiros
					Lj7GarEst(Nil,Nil,cProduto,aCols[n][nPosVlUnit])
				EndIf
			EndIf
		EndIf
	
						
	//Valida se a margem esta aceitavel.  
	If lMargem .AND. lRet
		If Lj701MgV(n) 
			If MsgYesNo(/*STR0094*/"O produto esta fora da margem de preço cadastrada. Deseja continuar ?")//"O produto esta fora da margem de preço cadastrada. Deseja continuar ?"
				If !LjProfile(35)
					Lj7ValDel(, ,  , ,.T.)			
					If Len(aColsDet) >= n
					   aColsDet[n][Len(aColsDet[n])] 	:= .T.
					EndIf  
					aColsDet[n][Len( aHeaderDet )+1]	:= .T.
					aCols[n][Len( aHeader )+1]	:= .T.				 
				EndIf	
			Else
				Lj7ValDel(, ,  , ,.T.)			
				If Len(aColsDet) >= n
				   aColsDet[n][Len(aColsDet[n])] 	:= .T.
				EndIf   			
				aColsDet[n][Len( aHeaderDet )+1]	:= .T.
				aCols[n][Len( aHeader )+1]	:= .T.
			EndIf	       
		EndIf                                                      
	EndIf					
	
	
	If lRet .And. nPosClasFis > 0 .And. (nPosClasFis := aPosCpo[nPosClasFis][2] ) > 0
		aCols[n][nPosClasFis] := iIf(FindFunction("Lj7RetClasFis"), Lj7RetClasFis(,,,,n), Space(TamSx3("LR_CLASFIS")[1]))
	EndIf
	
	If SL2->( FieldPos("L2_PREDIC")) > 0 .And. nPosPRedIc > 0 .And. n > 0 .And. MaFisFound("NF") .And. MaFisFound("IT",n)
		aCols[n][nPosPRedIc]  :=  MaFisRet(n,"IT_PREDIC")// %Redução da Base do ICMS	
	EndIf
	
	//Como o UPDLOJ09 se tornou obsoleto, executamos a funcao que estava no X3_VALID do campo LR_PRODUTO,
	// para verificar se o produto possui acessorios cadastrados (Kit de Produtos)
	//Adicionada validacao lItemKit para chamar apenas para produto pai
	If SuperGetMV("MV_LOJKIT",,.F.) .AND. !lItemKit 
		LjInfoKit()
	EndIf
	
	RestArea(aArea)		// Restaura area anterior

Return lRet

/*/{Protheus.doc} Lj7RegDesc
(long_description)
@author j2a.luizjunior
@since 02/08/2017
@version 1.0
@example
(examples)
@see (links_or_references)
/*/

Static Function XLj7RegDesc(cProduto,lVAssConc,aCols,aHeader,nQuant,lBonus,lDescCab,lScCsPreco,nKit)

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local lRet		:= .T.
Local nTotal	:= 0
Local nPValDsc	:= aScan(aHeader,{|x|AllTrim(x[2]) == "LR_VALDESC" })
Local nPDelet	:= Len(aHeader)+1
Local nValDscIt	:= 0
Local bSomaDsc	:= { |x| nValDscIt += If(x[nPDelet],0,x[nPValDsc])}
Local lDescRegr	:= .F.  
Local nPosCodReg  := Ascan(aHeaderDet,{|x|AllTrim(x[2])=="LR_CODREG"})		// Posicao do campo do codigo da Regra de desconto              
Local nPosVlDesR  := Ascan(aHeaderDet,{|x|AllTrim(x[2])=="LR_VLDESRE"})		// Posicao do campo do valor consedido pela regra de desconto   
Local cCodRegDe   := ""														// Codigo da Regra de desconto usada        				
Local nVlDesReg   := 0														// Valor de desconto consedido pela regra de desconto      

Default lDescCab	:= .F.
Default lScCsPreco	:= .F.													// Indica se a consulta de preco via WS esta habilitada
Default nKit			:= 0													//Quando cenario de venda e kit com desconto

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula o valor do item 									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
If lVAssConc

	If lCenVenda
		lDescRegr := LjDescItem(cProduto  , M->LQ_CLIENTE	, M->LQ_LOJA, nQuant,;
								@cCodRegDe, @nVlDesReg ) 
	EndIf
		
	lRet   		:= xLj7VlItem(Nil,lDescRegr,lBonus)	
	
	If lCenVenda .AND. lRet
		aEval( aCols, bSomaDsc )
		nTotal		:= xLj7T_Subtotal(2) + Lj7T_DescV(2) + nValDscIt
		lDescCab    := LjDescCab(	cProduto, M->LQ_CLIENTE	, M->LQ_LOJA	, @aCols	,;
					             	@aHeader, nTotal		) 
		
		If nPosCodReg > 0 			             	
			aColsDet[n][nPosCodReg] := cCodRegDe
		EndIf
		
		If nPosVlDesR > 0
			aColsDet[n][nPosVlDesR] := nVlDesReg
		EndIf	
	EndIf
	
Else    

	If (lRet := XLj7VlItem(Nil,lDescRegr,lBonus,Nil,;
							 Nil,Nil		,Nil	,Nil,;
							 Nil,Nil		,nKit))
		If lCenVenda .OR. lScCsPreco
			lDescRegr := LjDescItem(cProduto	, M->LQ_CLIENTE	, M->LQ_LOJA, nQuant,; 
									@cCodRegDe	, @nVlDesReg	, lScCsPreco) 
										
			aEval( aCols, bSomaDsc )
			nTotal	:= xLj7T_Subtotal(2) + Lj7T_DescV(2) + nValDscIt
			If lCenVenda
				lDescCab := LjDescCab(	cProduto, M->LQ_CLIENTE	, M->LQ_LOJA , @aCols,;
										@aHeader, nTotal		) 
			EndIf
					            	
			//If nPosCodReg > 0 			             	
			//	aColsDet[n][nPosCodReg] := cCodRegDe
			//EndIf				
				
			//If nPosVlDesR > 0				
			///	aColsDet[n][nPosVlDesR] := nVlDesReg
			//EndIf
		EndIf		
	EndIf

EndIf

Return lRet

Static Function xLj7VlItem( nField		, lRegrDesc	, lBonus	, lDescCab	,;
					lCalcDesc	, nValDes	, lIsRecCel	, nVlrRecarg,;
					lAlterProd 	, lScCsPreco, nKit 		, lIsRecCP	,;
					lReproVlIt )

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local aArea			:= GetArea()																		// Armazena area atual (alias, order e recno)
Local nPosItem 		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ITEM"})][2]				// Posicao da coluna Item
Local nPosProd		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})][2]			// Posicao da codigo do produto
Local nPosDescri	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_DESCRI"})][2]			// Posicao da descricao do produto
Local nPosQuant		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]				// Posicao da Quantidade
Local nPosVlUnit	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]				// Posicao do Valor unitario do item
Local nPosVlItem	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VLRITEM"})][2]			// Posicao do Valor do item
Local nPosDesc		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_DESC"})][2]				// Posicao do percentual de desconto
Local nPosValDesc	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VALDESC"})][2]			// Posicao do valor de desconto
Local nPosProvEnt	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PROVENT"})						// Posicao da provincia de entrega
Local nPosValGar	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_GARANT"})						// Posicao do Campo Garantia
Local nPosDtVldProd := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VLGAPRO"})					// Posicao do Campo Qtde dias validade da garantia do produto    
Local nPosPrcTab	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_PRCTAB"})						// Posicao do Preco de Tabela
Local nPosDtDProp	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DESCPRO"})						// Posicao do Desconto proporcional
Local nPosDtReserva	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_RESERVA"})						// Posicao do codigo da reserva
Local nPosDtLocal  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOCAL"})						// Posicao do local (armazem)
Local nPosLoteCtl	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOTECTL"})						// Posicao do lote do produto
Local nPosSubLote	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_NLOTE"})						// Posicao do sublote do produto
Local nPosLegCod	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_LEGCOD"})		   					// Posicao do Codigo do Abastecimento(TPL Posto -> Tabela LEG)
Local nTamB8_NUMLOTE:= TamSx3("B8_NUMLOTE")[1]															// Tamanho do campo B8_NUMLOTE
Local nTamB8_LOTECTL:= TamSx3("B8_LOTECTL")[1]															// Tamanho do campo B8_LOTECTL
Local nVlUnit 		:= 0																				// Valor unitario do produto (conf. tabela)
Local nQuant 		:= 0																				// Quantidade do produto
Local nAuxTotal		:= 0																				// Auxiliar para calculo do subtotal e total
Local nAuxQuant		:= 0																				// Auxiliar para calculo da quantidade total - Gorgulho	
Local nVlrDesc		:= 0																				// Auxiliar para calculo do valor do desconto
Local nVlrPDesc		:= 0																				// Auxiliar para calculo do valor do percentual do desconto
Local nValUnitAnt   := 0                                												// Valor Unitario atual                      
Local nDescPer      := LjGetProfile("DESCPER")															// Percentual de Desconto do Caixa Atual
Local nDescVal      := LjGetProfile("DESCVAL")          												// Valor de desconto do Caixa Atual
Local lEstNeg 		:= ( SuperGetMV("MV_ESTNEG",,"S") == "S" ) .OR. lMVLJPDVPA							// Indica se permite vender com estoque negativo
Local lTrcMoeda     := SuperGetMV("MV_TRCMOED",,.T.)													// Indica se permite escolha de moeda
Local cFormDesc  	:= SuperGetMV("MV_LJFORMD",.F.,"1" ) 												// Tipo de validacao do desconto (valor ou % / valor e %)
Local aDesc			:= {"V", 0}																			// Array com o Desconto
Local nDescP		:= 0																				// Utilizada para validacao do Percentual do Desconto
Local nDescV		:= 0																				// Utilizada para validacao do Valor do Desconto
Local cLocal 		:= ""                               												// Armazena o local padrao
Local nAuxPrItem    := 0	                               												// Valor do percentual (para o calculo do desconto)
Local nMoedaPrv     := 1   	                            												// Moeda da tabela de preco selecionada
Local nX            := 0	                               												// Variav. usada em lacos For...Next
Local cProd_cpo0    := ""                               												// Produto digitado 			Venda assistida concomitante
Local nQtd_cpo1     := 0      																			// Quantidade digitada          Venda assistida concomitante
Local nVlUn_cpo2    := 0																				// Valor unitario do Item		 
Local nVlPd_cpo3    := 0                                												// Percentual desconto digitado  Venda assistida concomitante
Local nVDes_cpo4    := 0                                												// Valor desconto digitado       Venda assistida concomitante
Local lVAssConc     := LjVassConc()																		// Indica se o cliente utiliza a Vda Assistida Concomitante
Local aTamL2DESC	:= TamSx3("L2_DESC")																// Array com os dados do campo L2_DESC
Local lAlterPre 	:= .F.																				// Se permite alteracao de preco
Local oDesconto																							// Instancia o objeto que fara o desconto
Local nMvLjTpDes	:= SuperGetMv( "MV_LJTPDES", , 0 )													// Indica qual desconto sera' utilizado 0 - Antigo / 1 - Novo (objeto)
Local cRastro  		:= SuperGetMV("MV_RASTRO")															// Verifica se a rastreabilidade esta' habilitada
Local nValorItem	:= 0																				// Valor do item que sera utilizado no calculo do desconto se MV_LJTPDES = 1
Local aDescBkp		:= {}																				// Armazena a linha do item atual antes de conceder descontos
Local lPcMult       := .F.																				// Verifica se o Produto digitado na consulta existe.
Local aColsTmp		:= {}																				// Acols temporario utilizado pela regra de descontos
Local lPrimItem		:= .T.																				// Indica se e o primeiro item nao deletado - zera o total para recalcular o imposto
Local nPosDtMont	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_FDTMONT"})
Local nPosDtEntr	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_FDTENTR"})
Local nTotal		:= 0																				// Total da venda sem descontos
Local nValDscIt		:= 0																				// Valor total de descontos nos itens
Local nPosDelet		:= Len(aHeader)+1																	// Posicao do controle de delecao de linha
Local nRegDesc		:= 0																				// Desconto proveniente da regra
Local nPrecoTab		:= 0																				// Variavel para armazenar o preco da tabela
Local nBKP			:= 0																				// Backup da variavel n
Local lRecalcIt		:= .F.																				// Controla se deve recalcular os itens apos alteracao no desconto no item e zerar o desconto total
Local nPosaCols     := n                                                                                // Bkp da linha possicionada no acols
Local nBkDesc  	:= aCols[n][nPosValDesc]																// Backup de valor antes de digitar
Local nBkPrcTab		:= 0																				// Backup do valor do produto
Local lR5			:= GetRpoRelease() >= "R5"  			  												// Indica se o release e 11.5
Local nTotalCF		:= 0																				// Valor total do cupom fiscal (diferente do total da nota)
Local nPosEntrega	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ENTREGA"})][2]			// Posicao da Unidade de Medida
Local cEntrega		:= ""																				// Tipo de entrega do item
Local lExLegSP10	:= FindFunction("Lj950SP10OK")														// Verifica a existencia da funcao que valida a legislacao paulista que limita o cupom fiscal em 10.000,00
Local lExTotalCF	:= FindFunction("LJXTotalCF")														// Verifica a existencia da funcao que calcula o total do cupom fiscal
Local lAutoExA		:= IsBlind()																		// Verifica se a rotina sera executada via execauto ou nao
Local lItemAbast	:= .F.																				// Sinaliza se item de abastecimento
Local nVlItem		:= 0																				// Valor do Item
Local nQtdItem		:= 0
Local lStatusImp13 	:= .F.																				// Status 13 do ECF. Indica se o ECF arredonda (.T.) ou trunca (.F.) o valor total
Local nSuframa      := 0                                                                                // Variavel para armazenar o valor de suframa
Local nY            := 0                                                                                // Variavel auxiliar usada em lacos For...Next
Local cCodPrdAux 	:= ""																				// Variavel auxiliar para armazenar o Codigo do Produto
Local lMvAjstDes	:= SuperGetMV("MV_LJAJDES", Nil, .F.)												// verifica se o parametro de ajuste de desconto esta ativo
Local lGE			:= FindFunction("LjUP104OK") .AND. LjUP104OK()										// Validação do Conceito Garantia Estendida 
Local nPosDtLojaRes	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_LOJARES"})			  			// Posicao do codigo da reserva - Garantia Estendida
Local nGarant	    := 0   
Local lLjcFid 		:= SuperGetMv("MV_LJCFID",,.F.) .AND. CrdxInt().AND. lR5							//Indica se a recarga de cartao fidelidade esta ativa
Local lMargem       := GetRpoRelease("R7") .AND. SuperGetMV("MV_LJMARGE",,.F.) 				            // Valida se considera a margem minIma no venda assistida.
Local nDiasGar		:= 0																				// Dias de Garantia
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.) .AND.  GetRpoRelease() >= "R5" .AND. ( SL1->((FieldPos("L1_ECFLAG") > 0) .AND. (L1_ECFLAG == "1"))  .OR. (FindFunction("LJ862ECAuto") .And. LJ862ECAuto()) )
Local nPosDescVal   := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALDESC"})	
Local lMvLjIPEn	 	:= SuperGetMV("MV_LJIPENP",, .F.) 
Local cCondBkp		:= "" //Backup da Condicao de Pagamento
Local lLJ8099		:= ExistBlock("LJ8099")   // Garantia Estendida	Ponto de entrada pra habilitar a Garantia Estendida Default .T.  
Local lValidCpo		:= .T.		// controle para verificacao na funcao estoque do loja Lj7SaldoBF
Local lIntSynt 	 	:= SuperGetMV("MV_LJSYNT",,"0") == "1"	 // Informa se a integracao Synthesis esta ativa
Local lRet 			:= .F.

Default nField 		:= 0
Default lRegrDesc	:= .F.			// Indica se a funcao foi acionada para preenchimento de desconto por regra
Default lBonus		:= .F.			// Define se o item se refere a bonificacao
Default lDescCab    := .F.  		// Indica se houve desconto pela regra de desconto no total da venda
Default lCalcDesc	:= .F.			// Controla se deve utiliza a variavel de memoria para calcular o desconto ou o aCols
Default nValDes		:= 0            // valida desconto
Default lIsRecCel 	:= .F.			// Indica que eh produto "Recarga de Celular"
Default nVlrRecarg 	:= 0			// Valor da "Recarga de Celular" ou da "Recarga de Cartao Presente (Gift Card)"
Default lAlterProd	:= .F.
Default lScCsPreco	:= .F.			// Indica se a consulta de preco via WS esta habilitada
Default nKit        := 0
Default lIsRecCP 	:= .F.	  		// Indica que eh produto "Recarga de Cartao Presente (Gift Card)"
Default lReproVlIt 	:= .F.

If Type("nPosIt") == "U" .And. (Len(aCols) > 0)
	nPosIt := aCols[n][nPosItem]		
EndIf
If lGe
	lRet := Lj7VlField()
	If !lRet
		Return lRet
	EndIf
	
	If Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_GARANT"}) > 0
		nGarant	    := aPosCpo[Ascan(aHeader,{|x| Alltrim(Upper(x[2])) == "LR_GARANT"})][2]	// Posicao do valor da garantia  
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inserida chamada da funcao Lj7VldUs, para que seja controlado³
//³  nos campos 1 = LR_QUANT, 2 = LR_VRUNIT , 3 = LR_DESC, e    ³
//³		4 = LR_VALDESC a integridade de vendedor/usuario 		³
//³        e também caso o release 11.5 esteja ativado.     	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lR5
	If (nField == 1) .OR. (nField == 2) .OR. (nField == 3) .OR. (nField == 4)
		If FindFunction("Lj7VldUs") .AND. !Lj7VldUs()
	   		lRet := .F.
			Return lRet
		EndIf	
    EndIf
EndIf

If cPaisLoc == "ARG" .AND. nField == 6
	If nPosProvEnt > 0
		nPosProvEnt	:= aPosCpo[nPosProvEnt][2]
		aCols[n][nPosProvEnt] := M->LR_PROVENT
		MaFisAlt("IT_PROVENT", aCols[n][nPosProvEnt], n)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Altera variavel private para desconto³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nValDes > 0  
	__ReadVar        := "M->LR_DESC" 
EndIf   
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso a Consulta Multimida esteja ativada nao vai usar ³
//³essa funcao.                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If HasTemplate("DRO")
	If T_DroSendPCM() 
		lPcMult :=  ExistCPO("SB1",M->LR_PRODUTO,1)
		Return (lPcMult)
	EndIf
Endif	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Limitacao de 10.000,00 - Legislacao Paulista 	³                 
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//
If nField == 1 .And. lExTotalCF .AND. lExLegSP10	 // Se o campo for [Quantidade]
	If nPosEntrega > 0
		If ValType(aCols[n][nPosEntrega]) == "C"
			cEntrega := aCols[n][nPosEntrega]
		EndIf
	EndIf
	
	If !LjNFFimVd() .AND. LJXTpRetira(cEntrega)  							// Se nao emitir Nota Fiscal e o produto for de Entrega = Retira ou Vazio
		nTotalCF := LJXTotalCF(n) + (aCols[n][nPosVlUnit] * M->LR_QUANT) 	// Obtem o total do Cupom Fiscal, considerando o item selecionado e sua quantidade digitada
		If !Lj950SP10OK(nTotalCF, 2)  										// Analisa se ultrapassou o limite da legislacao / [Deseja continuar? = NAO]. [Flag = 2 -> Indica que fara a pergunta se deseja continuar, caso ultrapasse o limite da legislacao]
			Lj7T_Total(2, xLj7T_Subtotal(2))									// Atualiza os totais da venda
			Return .F.					 	   								// Retona False / Sai da funcao
		EndIf																														
	EndIf  
EndIf


If ReadVar() == "M->LR_PRODUTO"
	If nPosDtMont > 0
		M->LR_FDTMONT 			:= Lj7PegaMontagem( &( ReadVar() ) )
		aCols[n][nPosDtMont] 	:= M->LR_FDTMONT
	EndIf
	If nPosDtEntr > 0
		M->LR_FDTENTR 			:= Lj7PegaEntrega( &( ReadVar() ) )
		aCols[n][nPosDtEntr] 	:= M->LR_FDTENTR
	EndIf
	If lFtvdVer12
		cTES := Posicione("SB1",1,xFilial("SB1") + M->LR_PRODUTO,"SB1->B1_TS")
		If !Empty(cTES)
			cTES := Posicione("SF4",1,xFilial("SF4") + cTES,"SF4->F4_CODIGO")
			If !RegistroOk("SF4")
				return .F.
			EndIf
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se chamada pelo valid do LR_DESC ou LR_VALDESC e o    ³
//³valor atual e o anterior for igual a zero retorna .T. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( nField == 3 .OR. nField == 4 ) .AND. M->LR_DESC == 0 .AND. M->LR_VALDESC == 0 .AND.;
		aCols[n][nPosDesc] == 0 .AND. aCols[n][nPosValDesc] == 0 .AND. !lCalcDesc
	Return .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao permitir alterar um item deletado     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( nField < 5 ) .AND. aCols[n][Len(aCols[n])]
	If !lAutoExA     
		MsgStop("Não é permitido modificar um item deletado.")		// "Não é permitido modificar um item deletado."
	Else
		Conout("Não é permitido modificar um item deletado.")		// "Não é permitido modificar um item deletado."
	EndIf 		
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao permite valor negativo no campo quantidade quando nao ha concomitancia     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nField == 1 .And. ReadVar() == "M->LR_QUANT" 
	If  M->LR_QUANT <= 0
		If !lAutoExA
			MsgStop("Valor nao permitido para esse campo.") // Valor nao permitido para esse campo.
		Else
		    Conout("Valor nao permitido para esse campo.") //Valor nao permitido para esse campo.
		EndIf	
		Return .F.
	ELse
		If !Lj7SaldoBF(lValidCpo)   // nvalid == 1 , 
			Return .F.
		EndIf	
	EndIf
EndIf      

//Verifica se o produto eh "Recarga de Celular" ou "Recarga de Cartao Presente" (Gift Card)
If (FindFunction("Lj7RCAtiva") .And. Lj7RCAtiva()) .Or. (FindFunction("Lj7CP_OK") .And. Lj7CP_OK() .And. Lj7CP_Ativ())
	If ReadVar() = "M->LR_PRODUTO"
		cCodPrdAux := &(ReadVar())
	Else
		cCodPrdAux := aCols[n][nPosProd]
	EndIf
	If !Empty(cCodPrdAux)
		lIsRecCel := Lj7RCPrdRC(cCodPrdAux)
		If lIsRecCel
			If ReadVar() $ "M->LR_QUANT|M->LR_DESC|M->LR_VALDESC"	
				MsgAlert("Não é permitido alterar este campo devido ser produto Recarga de Celular.") //"Não é permitido alterar este campo devido ser produto Recarga de Celular."
				Return .F.
			Else
				aCols[n][nPosVlUnit] := nVlrRecarg
			EndIf
		EndIf
		
		lIsRecCP := If(FindFunction("Lj7CP_Prod"),Lj7CP_Prod(cCodPrdAux),.F.)
		If lIsRecCP
			If ReadVar() $ "M->LR_QUANT|M->LR_DESC|M->LR_VALDESC"
				If ReadVar() $ "M->LR_QUANT"
					MsgAlert("Não é permitido alterar este campo devido ser produto Recarga de Cartão Presente.") //"Não é permitido alterar este campo devido ser produto Recarga de Cartão Presente."
					Return .F.
				EndIf
			Else
				aCols[n][nPosVlUnit] := nVlrRecarg
			EndIf
		EndIf
		
	EndIf
EndIf

If cPaisLoc == "ARG"
	If Empty(aCols[n][nPosProd])
		If !lAutoExA     
			MsgInfo("Ingrese el codigo de producto.")	// "Ingrese el codigo de producto."
		Else
			Conout("Ingrese el codigo de producto.")	// "Ingrese el codigo de producto."
		EndIf 				
		Return .F.
	EndIf

	If nField == 2
		nBkPrcTab := aColsDet[n][nPosPrcTab]
		aColsDet[n][nPosPrcTab] := &(ReadVar())
	ElseIf nField <> 0
		aCols[n][nPosVlUnit] := aColsDet[n][nPosPrcTab]
	EndIf
EndIf

If cPaisLoc <> "BRA" .AND. Lj7T_DescV(2) > 0
	If nRotina == 4 .AND. nField <> 5
		lRecalcIt := .T.
	EndIf
	//Verifica se foi alterado o valor do desconto no item da venda
	If ReadVar() $ "M->LR_QUANT|M->LR_PRODUTO|M->LR_DESC|M->LR_VALDESC" .And. MafisFound()
		Lj7LimpDes()
	EndIf
	Lj7T_DescV(2, 0)
	Lj7T_DescP(2, 0)
EndIf


If lMargem .AND. (nField == 3 .OR. nField == 4) .AND. (M->LR_DESC > 0 .OR. M->LR_VALDESC > 0 )
	//Valida se a margem esta aceitavel.      
	If Lj701MgV(n,, Iif(M->LR_DESC > 0,Round( (M->LR_DESC * aCols[n][nPosVlItem]) / 100, nDecimais ) , M->LR_VALDESC ) ) 
		If MsgYesNo("O produto esta fora da margem de preço cadastrada. Deseja continuar ?")//"O produto esta fora da margem de preço cadastrada. Deseja continuar ?"
			If !LjProfile(35)				
				Return .F.	
			EndIf	
		Else    	       
			Return .F.	
		EndIf	       
	EndIf                                                      
EndIf	 


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso o parametro esteja com 1, inicializa o objeto de ³
//³desconto.                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nMvLjTpDes == 1 .OR. nMvLjTpDes == 2
	oDesconto := Desconto():New()
Endif
		
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se nao for concomitante pego o valor a Variavel que acabou de receber a digitacao da quantidade          ³
//³ Se For Concomitante, entao pega o valor do Acols que recebeu a digitacao  								 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Relase 11.5 - Cartao Fidelidade 						 ³
//³Se chamada pelo valid do LR_QUANT e o produto for     ³
//³recarga de cartao de fidelidade, nao permite alterar o³ 
//³o valor atual que sera sempre 1						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If  nField == 1 .AND. (LaFunhProd(aCols[n][nPosProd])) .AND. (M->LR_QUANT <> 1)
	If !lAutoExA		
		MsgStop("A quantidade do produto para recarga de cartao fidelidade nao deve ser diferente de 1")	// "A quantidade do produto para recarga de cartao fidelidade nao deve ser diferente de 1"
	Else
		Conout("A quantidade do produto para recarga de cartao fidelidade nao deve ser diferente de 1")	// "A quantidade do produto para recarga de cartao fidelidade nao deve ser diferente de 1"
	EndIf
	Return .F.
EndIf
If lVAssConc
   cProd_cpo0 := Iif( lVAssConc .AND. nField==0, IiF( "LR_PRODUTO" $ ReadVar(),M->LR_PRODUTO,"") , gdFieldGet("LR_PRODUTO")) 
   nQtd_cpo1  := Iif( lVAssConc .AND. nField==0, gdFieldGet("LR_QUANT")  , IiF( "LR_QUANT" $ ReadVar(),M->LR_QUANT,0      ))
   nVlUn_cpo2 := Iif( lVAssConc .AND. nField==0, gdFieldGet("LR_VRUNIT") , IiF( "LR_VRUNIT" $ ReadVar(),M->LR_VRUNIT,0    ))
   nVlPd_cpo3 := Iif( lVAssConc .AND. nField==0, gdFieldGet("LR_DESC")   , IiF( "LR_DESC" $ ReadVar(),M->LR_DESC,0        ))
   nVDes_cpo4 := Iif( lVAssConc .AND. nField==0, gdFieldGet("LR_VALDESC"), IiF( "LR_VALDESC" $ ReadVar(),M->LR_VALDESC,0  ))
Endif   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Funcao utilizada para verificar a ultima versao dos fontes      ³
//³ SIGACUS.PRW, SIGACUSA.PRX e SIGACUSB.PRX, aplicados no rpo do   |
//| cliente, assim verificando a necessidade de uma atualizacao     |
//| nestes fontes. NAO REMOVER !!!							        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF !(FindFunction("SIGACUS_V") .AND. SIGACUS_V() >= 20050512)
    Final("Atualizar SIGACUS.PRW !!!")
Endif
IF !(FindFunction("SIGACUSA_V") .AND. SIGACUSA_V() >= 20050512)
    Final("Atualizar SIGACUSA.PRX !!!")
Endif
IF !(FindFunction("SIGACUSB_V") .AND. SIGACUSB_V() >= 20050512)
    Final("Atualizar SIGACUSB.PRX !!!")
Endif

lAlterPre := IIF(lAutoExA,.T.,LjCanAtuPr(SM0->M0_CGC))     

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Conforme legislacao, em alguns estados nao poderah alterar o valor do Produto. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nField == 2 .AND. !lAlterPre .AND. cPaisLoc == "BRA"
	Return .F.
EndIf
	
If lCenVenda
	If (nField == 3 .OR. nField == 4) .AND. !lRegrDesc .AND. !LjOpcDesc()
		If !lAutoExA     
			MsgStop("Não é permitido alterar o desconto atribuido pela regra de descontos, conforme a configuração do caixa atual.") //"Não é permitido alterar o desconto atribuido pela regra de descontos, conforme a configuração do caixa atual."
		Else
			ConOut("Não é permitido alterar o desconto atribuido pela regra de descontos, conforme a configuração do caixa atual.") //"Não é permitido alterar o desconto atribuido pela regra de descontos, conforme a configuração do caixa atual."
		EndIf	
		Return .F.
	EndIf
EndIf
	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao permite valor negativo no campo quantidade quando nao ha concomitancia ou se PAF-ECF     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lVAssConc .OR. LjNfPafEcf(SM0->M0_CGC)
	If nField == 1 .And. ReadVar() == "M->LR_QUANT" .AND. M->LR_QUANT <= 0
		If !lAutoExA     
			MsgStop("Valor nao permitido para esse campo.") // Valor nao permitido para esse campo.
		Else
			ConOut("Valor nao permitido para esse campo.") // Valor nao permitido para esse campo.
		EndIf		
		Return .F.
	EndIf      
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao permite efetuar alteracoes nos campos se jah foi efetuada³
//³ a reserva                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( "LR_" $ ReadVar() .And. &(ReadVar()) != GDFieldGet(Replace(ReadVar(),"M->","")) ) .And. ;
	( Len(aColsDet) >= n .AND. !Empty(aColsDet[n][nPosDtReserva]) .AND. !lFtvdVer12 .OR. ;
	Len(aColsDet) >= n .AND. !Empty(aColsDet[n][nPosDtReserva]) .AND. !lAutoExA .AND. lFtvdVer12 ) .AND. !lIntSynt
	If !lAutoExA     
		Aviso( "Aviso", "Já existe uma reserva para esse produto, não é possível ser alterado.", {"Ok"} ) //"Aviso"###"Já existe uma reserva para esse produto, não é possível ser alterado."###"Ok"
	Else
		ConOut("Já existe uma reserva para esse produto, não é possível ser alterado.") 
	EndIf		
	Return .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Armazena a linha atual (aCols e aColsDet). Quando o caixa nao³
//³teve sucesso na tentativa de conceder descontos, os valores  ³
//³antigos serao restaurados, mesmo que ja tenham sofrido algum ³
//³desconto                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
AAdd(aDescBkp,aClone(aCols[n]))
If Len(aColsDet) >= N
	AAdd(aDescBkp,aClone(aColsDet[n]))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifico se o Profile do usuario permite que execute descontos   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (nField == 3 .OR. nField == 4)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Caso queira alterar o desconto, volta o preco da venda para ³
	//³o original.                                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !Empty(aCols[n][nPosProd])
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Altera desconto percentual.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nField == 3 .AND. aCols[n][nPosDesc] <> 0 
			aCols[n][nPosVlUnit]	:= aColsDet[n][nPosPrcTab]  
			aCols[n][nPosVlItem]	:= A410Arred(aCols[n][nPosVlUnit] * aCols[n][nPosQuant],"LR_VLRITEM",nMoedaCor)
			aCols[n][nPosValDesc]	:= 0
			M->LR_VALDESC			:= 0
		EndIf   
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Altera desconto valor.     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nField == 4 .AND. aCols[n][nPosValDesc] <> 0
			aCols[n][nPosVlUnit]	:= aColsDet[n][nPosPrcTab]  
			aCols[n][nPosVlItem]	:= A410Arred(aCols[n][nPosVlUnit] * aCols[n][nPosQuant],"LR_VLRITEM",nMoedaCor)
			aCols[n][nPosDesc]		:= 0 
			aCols[n][nPosValDesc]	:= 0
			M->LR_DESC				:= 0
		EndIf                                        
	Endif
		
	If (nField == 3) .AND. !lCalcDesc
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    	//| Venda assistia concomitante, entao limpa o campo do Vlr.desconto qdo for digitado em Perc.Desconto  |
 		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   	
		If lVAssConc  // Quando e venda concomitante
           aCols[n][nPosValDesc] := 0
	       Return .T.
	    Else
			If !Empty(aCols[n][nPosProd])
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Validacao do Desconto. ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	           	nDescP := &(ReadVar())
				nDescV := aCols[n][nPosQuant] * aColsDet[n][nPosPrcTab] * IIf( ValType(nDescP) == "N", nDescP, 0)  / 100
		    	aDesc := {"P", nDescP}
		    	nPosIt := aCols[n][nPosItem]
	    	Endif
		EndIf
	ElseIf (nField == 4) .AND. !lCalcDesc
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    	//| Venda assistia concomitante, entao limpa o campo do Perc.desconto qdo for digitado em Vlr.Desconto  |
 		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   	
	    If lVAssConc
           aCols[n][nPosDesc] := 0
	       Return .T.
	    Else
			If !Empty(aCols[n][nPosProd])   
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Release 11.5 - Chile - F1CHI                               ³
				//³Sempre arredondar o valor do desconto digitado pelo usuario³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cPaisLoc == "CHI" .AND. lR5 .AND. M->LR_VALDESC > 0
					M->LR_VALDESC := A410Arred( M->LR_VALDESC,"LR_VALDESC",nMoedaCor)
				Endif	
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Validacao do Desconto. ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMvAjstDes
					nDescV := AjtDscIt( M->LR_VALDESC, aCols[n][nPosQuant] )
					M->LR_VALDESC := nDescV
				EndIf		            					
				nDescP := &(ReadVar()) * 100 / (aCols[n][nPosQuant] * aColsDet[n][nPosPrcTab])
	            nDescV := &(ReadVar())
				aDesc := {"V",nDescV}
				nPosIt := aCols[n][nPosItem]        
			Else
				nPosIt := aCols[n][nPosItem]
			Endif
		EndIf
	EndIf
	If !lRegrDesc .AND. !lCalcDesc .AND. !LjProfile(	11		, Nil	, aDesc		, nDescP	,;
					 nDescV	, Nil	, M->LQ_NUM, Nil, nPosIt )
		nDescP		:= 0
		nDescV		:= 0
		aDesc		:= {"V", 0}
		nPosIt		:= 0 
		aCols[n]	:= aClone(aDescBkp[1])
		If Len(aDescBkp) > 1
			aColsDet[n]	:= aClone(aDescBkp[2])
		EndIf
 		Return .F.
	EndIf
ElseIf nField == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Valida se o produto existe no SB1 e SB0                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea( "SB1" )
	DbSetOrder( 1 )
	If !DbSeek( xFilial("SB1") + aCols[n][nPosProd] )
		RestArea(aArea)
		If nBkPrcTab > 0
			aColsDet[n][nPosPrcTab] := nBkPrcTab
		EndIf
		Return .F.
	EndIf
	
	If !LjxeValPre (@nPrecoTab	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
					nMoedaCor	, aCols[n][nPosQuant])	

		If nBkPrcTab > 0
			aColsDet[n][nPosPrcTab] := nBkPrcTab
		EndIf

		Return .F.
	EndIf

EndIf
	
//Sinaliza que item de Abastecimento, considera valor do aCols
If ((nPosLegCod > 0) .AND. !Empty(aCols[n][nPosLegCod]))
	lItemAbast := .T.
EndIf                                      

If !Atail(aCols[n])	//verifica se o item mao esta deletado
   nVlItem	 := IIf(lItemAbast,0,aCols[n][nPosVlItem] )
   If nKit == 0 //Padrao
	   nAuxTotal := xLj7T_Subtotal(2) - If( MaFisFound("IT",n),MaFisRet( n, "IT_TOTAL" ),nVlItem )
   Else
	   nAuxTotal := xLj7T_Subtotal(2) //estava subtraindo o valor do primeiro produto do sub-total
   Endif
EndIf

DbSelectArea( "SB1" )
SB1->( DbSetOrder(1) )	//B1_FILIAL + B1_COD
If SB1->( DbSeek(xFilial("SB1") + aCols[n][nPosProd]) )
	
	// Caso o preco vim da execAuto ou Synteses pega o preco passado no array 
	If lRet .AND. ( lIntSynt .OR. (lAutoExA .AND. !Empty(aColsDet[n][nPosPrcTab]) ))  
		nPrecoTab := aColsDet[n][nPosPrcTab]
	ElseIf !XLjxeValPre (@nPrecoTab	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
					nMoedaCor	, If(nField==1,&(ReadVar()),aCols[n][nPosQuant]) )	
	    Return .F.
	EndIf
       
	If SB1->( FieldPos("B1_VALEPRE") > 0 .AND. B1_VALEPRE == "1" )
		If Iif( nField == 1, &(ReadVar()), aCols[N][nPosQuant] ) <> 1
			If nField == 1
				If !lAutoExA     
					//Aviso("Atenção","Vales presentes devem ser vendidos de 1 em 1 para que se possa controlar sua rastreabilidade.""Vales presentes devem ser vendidos de 1 em 1 para que se possa controlar sua rastreabilidade.", {"OK"} ) //"Atenção"#"Vales presentes devem ser vendidos de 1 em 1 para que se possa controlar sua rastreabilidade."#"OK"
				Else
					//ConOut("Vales presentes devem ser vendidos de 1 em 1 para que se possa controlar sua rastreabilidade.""Vales presentes devem ser vendidos de 1 em 1 para que se possa controlar sua rastreabilidade.", {"OK"} ) //"Atenção"#"Vales presentes devem ser vendidos de 1 em 1 para que se possa controlar sua rastreabilidade.")
				EndIf
				Return .F.
			Else
				aCols[N][nPosQuant] := 1
			EndIf
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se o produto utiliza controle por lote, valida a quantidade³
	//³solicitada                                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If  ((cRastro == "S") .AND. ((Len(aColsDet) >= N) .AND. (!Empty(aColsDet[n][nPosLoteCtl]))))		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o lote selecionado corresponde ao produto corrente³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SB8->(DbSetOrder(3)) //B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)		
		If SB8->(DbSeek(xFilial("SB8") + aCols[N][nPosProd] + aColsDet[N][nPosDtLocal] + aColsDet[N][nPosLoteCtl] + aColsDet[N][nPosSubLote]))	
			nQuant	:= If( nField == 1, &(ReadVar()), aCols[N][nPosQuant] )					
			If !Lj7Lote(aColsDet[N][nPosDtLocal], aColsDet[N][nPosLoteCtl], aColsDet[N][nPosSubLote], nQuant )
				RestArea(aArea)
				Return .F.
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se o produto do lote indicado nao corresponde, os dados do³
			//³lote sao limpos                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aColsDet[n][nPosLoteCtl] := Space(nTamB8_NUMLOTE)
			aColsDet[N][nPosSubLote] := Space(nTamB8_LOTECTL)
		EndIf		
	EndIf
   
   	If nField == 3 .OR. nField == 4
   		If nMvLjTpDes == 0
	   		If !(lECommerce .AND. lMvLjIPEn)
	   			nVlUnit := (aCols[n][nPosVlItem] + aCols[n][nPosValDesc]) / aCols[n][nPosQuant]
	   		ElseIf lMvLjIPEn
	   			nVlUnit := aColsDet[n][nPosPrcTab]
	   		EndIf
	   	ElseIf nMvLjTpDes == 2 
	   	    nValorItem := aColsDet[n][nPosPrcTab]	   	    
   	    	nVlUnit := nValorItem 	
	   	Else	
			LjxeValPre (@nValorItem	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
						nMoedaCor	, aCols[n][nPosQuant])
	   		nVlUnit	:= oDesconto:DescontoValor( nValorItem, aCols[n][nPosQuant], aCols[n][nPosValDesc] )    
	   	Endif	
	ElseIf nField == 2
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Só permite alterar o preco unitario se o usuario escolher uma tabela de preco  ³
		//³ zerada. Este é um conceito do SIGALOJA.                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nField == 2 .AND. nPrecoTab > 0 .AND. !lAlterPre
			Help( " ", 1, "LJ010NOVAL" )

			If nBkPrcTab > 0
				aColsDet[n][nPosPrcTab] := nBkPrcTab
			EndIf

			Return .F.
		EndIf
		
		nVlUnit := &(ReadVar())
	Else 
		If lFtvdVer12
			If ReadVar() == 'M->LR_TES' .And. nField == 0
				nVlUnit := aCols[n][nPosVlUnit]
			Else
				XLjxeValPre (@nVlUnit	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
					nMoedaCor	, If(nField==1,&(ReadVar()),aCols[n][nPosQuant]) )
			EndIf
		ElseIf !lFtvdVer12
			LjxeValPre (@nVlUnit	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
						nMoedaCor	, If(nField==1,&(ReadVar()),aCols[n][nPosQuant]) )
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se o preço da tabela for zero e a funcao for chamada da digita-	³
		//³ cao do campo quantidade (nField = 1) entao traz o valor digita-	³
		//³ do previamente, caso contrario, traz o valor da tabela         	³
		//³          														³
		//³ OU         														³
		//³          														³		
		//³Release 11.5 - Cartao Fidelidade									³
		//³Se o produto for do tipo recarga de cartão fidelidade            ³
		//³(ver parametro MV_LJPFID), o preco informado no cadastro   		³
		//³do produto sera desconsiderado.O valor mantido sera o       		³
		//³informado na tela de inclusao de saldo do cartao fidelidade.		³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				
		If (nVlUnit == 0 .AND. nField = 1) .OR. (lLjcFid .AND. LaFunhProd(aCols[n][nPosProd]))
			nVlUnit := (aCols[n][nPosVlItem] + aCols[n][nPosValDesc]) / aCols[n][nPosQuant]	
		EndIf
		               
	    If lTrcMoeda .AND. !lCenVenda
	       nMoedaPrv := Max(&("SB0->B0_MOEDA" + Lj7DefTab()),1)
		   nVlUnit   := Round(xMoeda(&("SB0->B0_PRV" + Lj7DefTab()),nMoedaPrv,nMoedaCor,dDataBase,nDecimais+1,,nTxMoeda),nDecimais)
	    EndIf   					
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for item de Abastecimento(TPL POSTO) ou finalizacao de Lay-Away, considerar o valor ja preenchido no aCols ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
	If lItemAbast .OR. ((cPaisLoc$"EUA|POR" .OR. (cPaisLoc$"MEX|COL" .AND. LR5)) .AND. lLayAway) .OR. ( (lIsRecCel .Or. lIsRecCP .Or. lAutoExA) .And. aCols[n][nPosVlUnit] > 0 )
	   nVlUnit  := aCols[n][nPosVlUnit]
	Endif
                   
	//Checar se o valor digitado no desconto por valor, eh maior que o B0_PRV mais a tabela selecionada
	If ( nField == 4 ) .AND. ( M->LR_VALDESC >= (A410Arred(nVlUnit * aCols[n][nPosQuant],"LR_VLRITEM",nMoedaCor)) )
		If !lAutoExA     
			Aviso("Atenção","O valor do desconto é maior ou igual ao valor do item, verifique !",{"Ok"} ) //"Atenção"###"O valor do desconto é maior ou igual ao valor do item, verifique !"###"Ok"
		Else
			ConOut("O valor do desconto é maior ou igual ao valor do item, verifique !")
			Help( " ", 1, "Help",, "O valor do desconto é maior ou igual ao valor do item, verifique !", 1, 0 )
		EndIf
		RestArea(aArea)
		Return .F.
	EndIf       
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida se o valor unitário foi alterado, zera os descontos³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (!lCenVenda .OR. lFtvdVer12).AND. !lScCsPreco .AND. (nKit == 0)
		If ReadVar()$"M->LR_QUANT|M->LR_VRUNIT|M->LR_PRODUTO"
			Lj7T_DescP(2,0)
			Lj7T_DescV(2,0)
			If "M->LR_PRODUTO"$ReadVar()
				aCols[n][nPosDesc]		:= 0                   
				aCols[n][nPosValDesc]	:= 0
			Endif
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atribui valor unitario										 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValUnitAnt          := aCols[n][nPosVlUnit]
	aCols[n][nPosVlUnit] := nVlUnit
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula valor do item										 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nQuant					:= If( nField=1, &(ReadVar()), aCols[n][nPosQuant] )


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para indicar se o ECF faz o arredondamento (.T.) ou ³
	//³ truncamento (.F.) dos valores.                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("FRTECF13")
	    lStatusImp13 := ExecBlock("FRTECF13",.F.,.F.,{aCols[n][nPosProd],aCols[n][nPosVlUnit], nQuant})
		If lStatusImp13  // Se o ECF Nao Tem Arredondamento
			aCols[n][nPosVlItem]	:= Round( nQuant * aCols[n][nPosVlUnit], TamSx3("D2_TOTAL")[2]) 
		Else	
			aCols[n][nPosVlItem]	:= NoRound( nQuant * aCols[n][nPosVlUnit], TamSx3("D2_TOTAL")[2]) 
		EndIf	
	Else
		aCols[n][nPosVlItem]	:= a410Arred( nQuant * aCols[n][nPosVlUnit], "D2_TOTAL")
	Endif   

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se permite vender com estoque negativo. Aqui soh    ³
	//³ faz um alerta e não trava a operacao, pois poderah se tratar ³
	//³ de um orcamento ou de uma reserva para outra loja.           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nField == 1 .AND. !lEstNeg
		If Len(aColsDet) >= n
			cLocal := aColsDet[n][nPosDtLocal]
		Else
			cLocal := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
		Endif
		Lj7VerEst( aCols[n][nPosProd], cLocal, nQuant, .T. )
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se ha desconto (valor e ou percentual)              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nField == 1

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica a regra de descontos de acordo com a quantidade³
		//³vendida - Cenario de vendas                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (((SB1->( FieldPos("B1_DESCONT")) > 0)  	.AND. (SB1->B1_DESCONT > 0))  .OR. lLJ8099)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula o desconto a partir do PE ou B1 %S³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLJ8099   		
				aCols[n][nPosDesc]	:= Execblock( "LJ8099", .F., .F. )
		 	Else
		 		aCols[n][nPosDesc]	:= SB1->B1_DESCONT
		 	EndIf
		ElseIf lCenVenda
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula o desconto a partir da regra de descontos - ITENS³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nRegDesc := LjRgrDesc(aCols[n][nPosProd],M->LQ_CLIENTE,M->LQ_LOJA,cTabPad,M->LR_QUANT ,1)
			
			aCols[n][nPosDesc] := nRegDesc
		
		EndIf
		
		nAuxPrItem := aCols[n][nPosDesc]
		
		If aCols[n][nPosValDesc] > 0 .OR. lCenVenda
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se o percentual de desconto for maior que 0, refaz o cálculo do valor do desconto. ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    If nMvLjTpDes == 0
			    nVlrDesc := Round( aCols[n,nPosDesc] * aCols[n][nPosVlItem] / 100, nDecimais )
			ElseIf nMvLjTpDes == 2
    		   If  aCols[n][nPosValDesc] > 0 
    				nVlUnit := aColsDet[n][nPosPrcTab]
	    			nVlrPDesc := oDesconto:CalcPerDes(@nVlUnit, @nVlrDesc ,nQuant ) 	
    	   		EndIf	
	    		If aCols[n][nPosDesc] > 0   
	    			nVlUnit := aColsDet[n][nPosPrcTab]
	    			nVlrDesc := oDesconto:CalcValDes( @nVlUnit , aCols[n][nPosDesc], nQuant )
	    		EndIf			
			Else
				nVlrDesc := oDesconto:ValidaValor( aCols[n][nPosDesc], nVlUnit, nQuant )
			Endif
		    aCols[n][nPosValDesc] 	:= nVlrDesc
		    
		    aCols[n][nPosVlItem]	-= nVlrDesc
 		    If nMvLjTpDes <> 2
 		       	aCols[n][nPosVlUnit] := ( aCols[n][nPosVlItem] / &(ReadVar()) )  
 		    Else
 		       	aCols[n][nPosVlUnit] := nVlUnit
		    EndIf
			aDesconto				:= { 0, 0, 0 }

		EndIf   

	ElseIf nField == 2
		If aCols[n][nPosValDesc] > 0 .AND. nValUnitAnt <> &(ReadVar()) 
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se alterar o valor do item unitario, zera os descontos                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    nVlrDesc 				:= 0
		    aCols[n][nPosValDesc] 	:= 0
		    aCols[n][nPosDesc] 		:= 0
			aDesconto				:= { 0, 0, 0 }
			
		EndIf		

	ElseIf nField == 3
	    If nMvLjTpDes == 0
	        nVlrPDesc := aCols[n][nPosDesc]		//guardando % de desconto anterior
	    	nVlrDesc  := Round( IIf(lCalcDesc, aCols[n][nPosDesc], M->LR_DESC) * aCols[n][nPosVlItem] / 100, nDecimais )
	    ElseIf nMvljTpDes == 2
	    	If !Empty ( M->LR_VALDESC ) .AND.  M->LR_VALDESC > 0  
	    		nVlrPDesc := oDesconto:CalcPerDes(@nVlUnit, nVlrDesc , nQuant ) 	
	    	EndIf	
	    	If !Empty ( M->LR_DESC ) .AND. M->LR_DESC > 0     
	    		nVlrDesc := oDesconto:CalcValDes( @nVlUnit , M->LR_DESC , nQuant )
	    	EndIf
	    Else	
		    If IIf(lCalcDesc, Empty( aCols[n][nPosDesc] ), Empty( M->LR_DESC ))
		    	nVlrPDesc := oDesconto:ValidaPercent( nVlrDesc, nVlUnit, nQuant )
		    EndIf
		    
		    If IIf(lCalcDesc, Empty( aCols[n][nPosValDesc] ), Empty( M->LR_VALDESC )) .OR. aCols[n][nPosValDesc] == 0
		    	nVlrDesc := oDesconto:ValidaValor( IIf(lCalcDesc, aCols[n][nPosDesc], M->LR_DESC), nVlUnit, nQuant )
		    Endif	 
		EndIf    
	    
		// Ajusta o Valor de desconto
	    aCols[n][nPosDesc]		:= nVlrPDesc
	    aCols[n][nPosValDesc] 	:= nVlrDesc
	ElseIf nField == 4
		If !nMvLjTpDes == 2	
			nVlrDesc 				:= IIf(lCalcDesc, aCols[n][nPosValDesc], M->LR_VALDESC)
			nVlrPDesc 				:= Round( nVlrDesc * 100 / aCols[n][nPosVlItem], aTamL2DESC[2] )
			// Ajusta o Percentual de desconto
			aCols[n][nPosDesc]		:= nVlrPDesc	    
		Else
		    If M->LR_VALDESC > 0
		    	If lMvAjstDes
					M->LR_VALDESC := AjtDscIt( M->LR_VALDESC, aCols[n][nPosQuant] )
				EndIf
		    	nVlrDesc :=	M->LR_VALDESC
		    EndIf
		    If nVlrDesc > 0  
				nVlrPDesc := oDesconto:CalcPerDes(@nVlUnit, nVlrDesc , nQuant )  	 
				aCols[n][nPosDesc] := nVlrPDesc 			
			EndIf	
		EndIf
	Endif
	
	// Ajusta os valores de preco unitario e total do item
	If nField == 3 .OR. nField == 4
    	If nMvLjTpDes == 0  .OR. nMvLjTpDes == 1
    		aCols[n][nPosVlItem]	-= nVlrDesc
    		aCols[n][nPosVlUnit]	:= aCols[n][nPosVlItem] / aCols[n][nPosQuant] 
    	Else
    	    aCols[n][nPosVlItem] 	-= nVlrDesc  
       		aCols[n][nPosVlUnit]	:= nVlUnit 
    	EndIf	
	Endif		

	If GetRpoRelease("R7") .AND. nField == 0 .AND. nKit == 1 
		If aCols[n][nPosDesc] > 0//Se o percentual de desconto for maior que 0
	
		    nVlrDesc := Round( aCols[n,nPosDesc] * aCols[n][nPosVlItem] / 100, nDecimais )
			
			// Ajusta o Valor de desconto
		    If nVlrDesc <> 0
			    aCols[n][nPosValDesc] 	:= nVlrDesc
			    aCols[n][nPosVlItem]	-= nVlrDesc
			    aCols[n][nPosVlUnit]    -= nVlrDesc/aCols[n][nPosQuant]
		    Endif	
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz o ajuste do array de Detalhe dos produtos e chama as     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	If lVAssConc .AND. nField==0   // Quando e venda concomitante
       
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifico os valores dos descontos digitados ou percentual ou valor   ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nVlPd_cpo3 <> 0  
			nVlrDesc 			:= Round( nVlPd_cpo3 * aCols[n][nPosVlItem] / 100, nDecimais )
			nVlrPDesc			:= nVlPd_cpo3
			aCols[n][nPosDesc]	:= nVlPd_cpo3 
		ElseIf nVDes_cpo4 <> 0  
			nVlrDesc			:= nVDes_cpo4
			nVlrPDesc 			:= Round( nVlrDesc * 100 / aCols[n][nPosVlItem], aTamL2DESC[2] )
			aCols[n][nPosDesc]	:= nVlrPDesc
		Else
			nVlrDesc := 0
		Endif   

  		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o considera % OU valor de desconto, ou, ³
		//³% E valor de desconto                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cFormDesc == "1"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Chamado a partir do GET da porcentagem.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nVlPd_cpo3<>0             
				aDesc := { "P", nVlrPDesc }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Chamado a partir do GET do valor.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf nVDes_cpo4<>0        
				aDesc := { "V", nVlrDesc }
			EndIf

		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se o caixa nao puder conceder o desconto informado no acols, desfaz³
		//³todas as alteracoes realizadas no item ate este ponto da funcao.   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lRegrDesc .AND. !LJProfile(11, Nil, aDesc, nVlrPDesc, nVlrDesc)

			If Len(aDescBkp) > 1
				aColsDet[n]			:= aClone(aDescBkp[2])
			EndIf

			aCols[n]   		   		:= aClone(aDescBkp[1])
			aCols[n][nPosProd] 		:= ""
			aCols[n][nPosDescri]	:= ""
			M->LR_PRODUTO 			:= ""
			
			RestArea(aArea)
			Return .F.
	
		EndIf	
		
		If nVlrDesc <> 0
		//somente atualizo o Valor Unitario, caso valor de desconto <> 0
			aCols[n][nPosVlItem]	-= nVlrDesc
			aCols[n][nPosVlUnit]	:= aCols[n][nPosVlItem] / aCols[n][nPosQuant]
			aCols[n][nPosValDesc]	:= nVlrDesc
		EndIf

	Endif
    
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz o ajuste do array de Detalhe dos produtos e chama as     ³
	//³ funcoes fiscais para calcular os impostos                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lFtvdVer12
		LJ7Detalhe(Nil, lAlterProd, Nil, Nil, lIsRecCP, aCols[n][nPosVlUnit], lReproVlIt)
	ElseIf lFtvdVer12
		LJ7Detalhe(, , ,ReadVar())
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Faz ajuste do acols, porque a rotina está zerando mesmo ³
	//³quando é chamada da validação do Item com desconto.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (nValDes > 0 .Or. ReadVar()=="M->LR_DESC") .AND. (nVlrDesc > 0)
		aCols[n][nPosDesc] 	:= &(ReadVar())
	EndIf   
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Realiza o calculo do Suframa, quando o cliente for Apto a recebe-lo³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "BRA" .AND. MaFisRet(,"NF_SUFRAMA")
		nSuframa := LjVDSuframa()
	EndIf 
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o valor de desconto do suframa     				 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
	If Len(aTotais) > 6 .AND. lFtvdVer12
		LjVDT_SUFR( 2, nSuframa	)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Subtotal e Total jah com os impostos calculados     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "BRA" .AND. !aCols[n][Len(aHeader) + 1] .AND. !lFtvdVer12
	   nAuxTotal := nAuxTotal + If( MaFisFound("IT",n),MaFisRet( n, "IT_TOTAL" ),aCols[n][nPosVlItem] )
	ElseIf lFtvdVer12
		nAuxTotal := MaFisRet(, "NF_TOTAL" )
	EndIf

	If cPaisLoc <> "BRA" .And. nRotina == 4
		aCols[n][nPosValDesc] 	:= nVlrDesc
		If lRecalcIt
			//Zera o desconto proporcional dos itens devido ter zerado o desconto no total
			For nX := 1 To Len(aCols)
				If !aCols[nX][Len(aCols[nX])]
					aColsDet[nX][nPosDtDProp] := 0
				EndIf
			Next nX
		EndIf
	EndIf

	If !Atail(aCols[n]) .AND. !lCalcDesc
		// Significa que o usuario incluiu um novo produto ou alterou algum item após determinar
		// um desconto no total. Nesse caso é necessário recalcular os impostos para todos os itens.		
		If cPaisLoc <> "BRA"

			Lj7T_Total( 2, 0 )
			xLj7T_Subtotal( 2, 0 )
			XLj7T_Quant( 2, 0 )			
			aTotImpsV := {} //Limpa array com o total dos Impostos Variaveis que serao recalculados logo abaixo
			
			For nX := 1 To Len(aCols)   
				If !aCols[nX][Len(aCols[nX])]
					Lj7RecalImp(nX	, 1  , NIL ,	NIL,;
								NIL	, NIL, NIL, .T. )
				EndIf
			Next nX
			lRecalcIt := .F.
		Else
			xLj7T_Subtotal( 2, nAuxTotal )
    		
    		nAuxQuant := xLj7CalcQtd(aCols,n,nQuant)
			
			IIF(!MaFisRet(,"NF_SUFRAMA"),XLj7T_Quant( 2, nAuxQuant ),Nil)        
	
			If !lDescCab .And. LjOpcDesc()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Caso possua desconto no total e foi informado desconto no item,                           ³
				//³O desconto no total eh zerado pois não pode ser recalculado, o que implicaria em verificar³
				//³a pemissao do usuario. Neste caso deve ser informado novamente o desconto no total.       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Lj7T_DescV(2) > 0 .AND. nVlrDesc > 0
					Lj7T_DescV(2, 0)
					Lj7T_DescP(2, 0)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//|Se os descontos sao aplicados nessa ordem: 1-desconto no ITEM, 2-desconto no TOTAL e por ultimo,	|
				//| ZERA-SE o desconto no ITEM, o sistema deve reaplicar automaticamente o desconto no TOTAL.		|
				//|Mas se for aplicado um novo desconto no IT, o desconto no TOTAL deve ser reaplicado manualmente	|
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf Lj7T_DescP(2) > 0 .AND. nVlrDesc <= 0
					nPerDesc := Lj7T_DescP(2)
					nVlrDesc := nVlrDescBkp := Round((xLj7T_Subtotal(2) - MAFisRet(,"NF_VALSOL")) * nPerDesc / 100, nDecimais )
					Lj7T_DescV(2, nVlrDesc)
					Lj7T_DescP(2, nPerDesc)
				EndIf
			EndIf
			Lj7T_Total( 2, xLj7T_Subtotal(2) - Lj7T_DescV(2) )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ao alterar o produto, verifica se novo total eh menor ou igual a 0 ³
			//³(devido aos descontos) se for, zera os descontos e refaz o calculo ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aTotais[4][2] <= 0
				Lj7T_DescV(2, 0)
				Lj7T_DescP(2, 0)				
				Lj7T_Total	( 2, xLj7T_Subtotal(2) - Lj7T_DescV(2) )
			Endif

			//Armazena Condicao de Pagamento Atual			
			If M->LQ_CONDPG <> Nil
				cCondBkp := M->LQ_CONDPG
			EndIf
			
			Lj7ZeraPgtos( NIL, NIL, .F. )
			aDesconto := { 0, 0, 0 }
			
			//Restaura Condição de Pagamento, necessário para Regra de Desconto pois Lj7ZeraPgtos limpa M->LQCONDPG
			If cCondBkp <> Nil
				M->LQ_CONDPG := cCondBkp
			EndIf
		EndIf              
	Endif
			
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calcula o desconto da venda a partir das regras de desconto³
	//³do cenario de vendas                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nField == 1 .AND. lCenVenda
	
		aColsTmp	:= aClone(aCols)  
		aColsTmp[n][nPosQuant] := M->LR_QUANT
	                                        
  		nValDscIt	:= 0
		aEval( aCols, { |x| nValDscIt += If(x[nPosDelet],0,x[nPosValDesc])} )
		nTotal		:= xLj7T_Subtotal(2) + Lj7T_DescV(2) + nValDscIt
	
		LjDescCab(	aColsTmp[n][nPosProd]	, M->LQ_CLIENTE	, M->LQ_LOJA	, @aColsTmp	,;
					@aHeader				, nTotal		)
		
	EndIf
EndIf

If cPaisLoc == "ARG"
	M->LR_VALDESC := aCols[n][nPosValDesc]
EndIf

Eval(bRefresh) 

If nPosaCols <> n 
	n := nPosaCols
EndIf	

RestArea(aArea)											// Restaura area anterior

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso parametro for .T. faz tratamento de pedi classificação de desconto³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRegrDesc .AND. Lj7Mv_Desc() .AND. !lAutoExA
    
    If oMotivoDes == Nil
		oMotivoDes := LJCClaDes():New()	
	EndIf
	
	If 	(!aCols[n][nPosValDesc] == 0)  .AND.  (nBkDesc  <> aCols[n][nPosValDesc])	 .AND.;
		(nField == 3 .OR. nField == 4) 
		
		If !oMotivoDes:ChamaTela(n)
			If Len(aDescBkp) > 1
				aColsDet[n]			:= aClone(aDescBkp[2])
			EndIf
			aCols[n]   		   		:= aClone(aDescBkp[1])
			Return .F.
		EndIF
	ElseIf aCols[n][nPosValDesc] == 0  .AND.	(nField == 3 .OR. nField == 4)
		oMotivoDes:RmValida(n)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  
//³ Grava Qtde dias da validade da garantia do produto   ³   
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ        
If lGE .AND. nPosDtVldProd > 0 .AND. Len(aColsDet) >= n    
    
	If lCenVenda .AND. ExistBlock("LJ7080")
		nDiasGar := ExecBlock("LJ7080",.F.,.F.,{aCols[n][nPosProd]})
	Else
		nDiasGar := SB0->B0_DIASGAR
	EndIf	
	
	aColsDet[n][nPosDtVldProd] := nDiasGar
	
EndIf

Return .T.

Static Function XLjxeValPre(nPrecoTab, cProduto, cCliente, cLoja    ,;
					        nMoeda   , nQtdade , lProdON , nValIpiEC,;
					        lTabIPI)

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local lRet 			:= .T.  	// Variavel de retorno
Local aArea			:= {}		// Armazena area atual (alias, order e recno)
Local aAreaDA0		:= {}		// Armazena area do DA0 (alias, order e recno)
Local cTabPrecos    := ""		// Parametro da tabela de preco padrao
Local lLjCnVB0		:= SuperGetMv("MV_LJCNVB0",,.F.)		// Retorna preço da SB0 na ausência do preço do Produto na DA0 e DA1
Local lFtvdVer12		:= FindFunction("LjFTvd") .AND. LjFTVD() //Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local cNomeProg		:= Iif(lFtvdVer12,"FATA701","LOJA701") //Nome da Rotina
Local cMvLjRetVl	:= SuperGetMV("MV_LJRETVL",,"3") // 1=Retorna o menor preco de uma tabela | 2=Retorna o maior preco de uma tabela | 3=Considera preco da tabela configurada no parametro MV_TABPAD
Local cMsgPdZero 	:= ""  		// Mensagem a ser apresentada qdo. produto estiver com preco zerado
Local lMvGarFP		:= SuperGetMV("MV_LJGarFP", ,.F.)	    // Define o conceito do preço da Garantia Estendida
Local cMvLjTGar	    := SuperGetMV("MV_LJTPGAR",,"GE") 												// Define se é tipo GE 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para eCommerce       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.) .And. GetRpoRelease() >= "R5" .And. ( (FindFunction("LJ862ECAuto") .And. LJ862ECAuto()))//Funcao auto pela Exportacao.  
Local lECCia		:= SuperGetMV("MV_LJECOMM",,.F.) .And. SuperGetMV("MV_LJECOMO",,.F.) .AND. ( FindFunction("Lj901Auto")  .AND. Lj901Auto() )

Local lMvLjIPEn		:= SuperGetMV("MV_LJIPENP",, .F.)      
Local nPosDtVlDs    := 0
Local aAreaSB1		:= {}
Local aAreaSF4		:= {}
Local lMVRNDIPI		:= SuperGetMV("MV_RNDIPI",,.F.) //Arredonda IPI?
Local nCasasIPI		:= SLR->(TamSX3("LR_VALIPI")[2])
Local cTES			:= SuperGetMV("MV_LJTESPE", NIL, "501")  
Local nValIPIEn    := 0    
Local cTabPad		:= ""
Local nIteracao 	:= 1     
Local lLj901APrc	:= FindFunction("Lj901APrc")


Default nPrecoTab 	:= 0										// Valor default
Default cProduto    	:= ""
Default cCliente		:= SuperGetMV("MV_CLIPAD")		
Default cLoja			:= SuperGetMV("MV_LOJAPAD")
Default nMoeda			:= 1
Default nQtdade 		:= 1
DEFAULT lProdON 		:= .F.   
DEFAULT nValIpiEC		:= 0 
DEFAULT lTabIPI			:= .F.

aArea		:= GetArea()

If Empty(M->LQ_XTAB)
	cTabPrecos := LjXETabPre(cCliente,cLoja)
Else
	cTabPrecos := M->LQ_XTAB
EndIf	 

If lCenVenda
       	
	aAreaDA0 := DA0->(GetArea())
	
	DbSelectArea("DA0")
	DA1->(DbSetOrder(1))//DA0_FILIAL+DA0_CODTAB  

	If DA1->(DbSeek(xFilial("DA0")+cTabPrecos))          	
        If lECCia .AND. lLj901APrc  
        
        	lRet := Lj901APrc( @nPrecoTab)

			LjGrvLog("", "Validando preço Cenario de Vendas " + cValToChar(nPrecoTab) + " Retorno " + cValToChar(lRet))

		ElseIf (lNovRegDesc .And. nModulo <> 23)

			// Se o produto for garantia e houver faixa de preco 
			If SB1->B1_TIPO == cMvLjTGar
				If nRet = 0
				
					DbSelectArea("DA1")
					DbSetOrder(1)
					If DbSeek(xFilial("DA1") + cTabPrecos + cProduto)
						nPrecoTab := DA1->DA1_PRCVEN
					EndIf
				
				EndIF	
			EndIf
			
			nPrecoTab := LjxeTPreco(cProduto, cCliente, cLoja, nMoeda, nQtdade, cTabPrecos)

			If nPrecoTab == 0 .AND. FindFunction("RGDesIteVlProd") //Loja 3025  
				nPrecoTab := RGDesIteVlProd(cProduto)				
			EndIf 
			
			If nPrecoTab == 0 
				//STR0011 - "Para regra de desconto ser aplicada, deve constar o produto "
				//STR0012 - " na tabela de preço: "
				MsgAlert("Para regra de desconto ser aplicada, deve constar o produto " + cProduto + CRLF + " na tabela de preço: " + cTabPrecos)
				lRet := .F.
			EndIf			
		Else
			If nQtdade == 0
				nQtdade := 1
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Realiza a busca do preco do produto na Tabela de Precos³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ               
			
			If lCenVenda .AND. FindFunction("LjxFindTab")						
				LjxClFindT()	//Limpa o array estatico do LOJA701E
				LjxFindTab(cCliente, cLoja)	//Busca no LOJA701E se existem tabelas de preco ativa	
			EndIf			
			
				nPrecoTab := XLjXETPreco(cProduto, cCliente, cLoja, nMoeda, nQtdade, cTabPrecos)
				
				/*
				DbSelectArea("DA1")
				DbSetOrder(1)
				If DbSeek(xFilial("DA1") + cTabPrecos + cProduto)
					nPrecoTab := DA1->DA1_PRCVEN
				EndIf			
				*/
				
		  	If nPrecoTab == 0 
				//"Preço do produto zerado ou não cadastrado na tabela de preços "j2a.luiz	j2a
				cMsgPdZero := "Preço do produto zerado ou não cadastrado na tabela de preços " + If(cMvLjRetVl=="3",cTabPrecos,"")
				MsgAlert(cMsgPdZero)
				lRet := .F.
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso o preco retorne zero, atualiza o valor default de ³
			//³acordo com o produto cadastro                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nPrecoTab == 0 .AND. nModulo == 23
				DbSelectArea("SBI")
				DbSetOrder(1)
				If DbSeek(xFilial("SBI")+cProduto)
					nPrecoTab := SBI->BI_PRV
				EndIf
			ElseIf nPrecoTab == 0 .AND. (nModulo == 12 .OR. nModulo == 72)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifica se retorna o valor default do SB1 (conforme range³
					//³a regra do Cenario de Vendas), ou do SB0                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lLjCnVB0
						DbSelectArea("SB0") 
						DbSetOrder(1)
						If DbSeek(xFilial("SB0")+cProduto)
							If  lECommerce
								cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,SuperGetMV("MV_TABPAD")))
								nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
							Else
								nPrecoTab := SB0->B0_PRV1
							EndIf	
						EndIf
					Else
						DbSelectArea("SB1") 
						DbSetOrder(1)
						If MsSeek(xFilial("SB1")+cProduto)
							nPrecoTab := SB1->B1_PRV1
						EndIf						
					EndIf 
			EndIf
		EndIf
	Else  
		If !Isblind()
			MsgAlert("Tabela de preco invalida no parametro MV_TABPAD") //"Tabela de preco invalida no parametro MV_TABPAD"
		Else 
			ConOut("Tabela de preco invalida no parametro MV_TABPAD")//"Tabela de preco invalida no parametro MV_TABPAD"
		EndIf
		lRet := .F.
    EndIf  
    
	RestArea(aAreaDA0)	
	
	If nPrecoTab == 0 .And. Empty(cMsgPdZero)
		//"Preço do produto zerado ou não cadastrado na tabela de preços "
		cMsgPdZero := "Preço do produto zerado ou não cadastrado na tabela de preços " + If(cMvLjRetVl=="3",cTabPrecos,"")
		If !Isblind()
			MsgAlert(cMsgPdZero)
		Else
			ConOut(cMsgPdZero)
		EndIf
		lRet := .F.
	EndIf		  

Else            
	If (nModulo <> 23 .AND. !IsInCallStack("Crd240Criterio") .AND. !IsInCallStack("Frt080Prod") .AND. !lFtvdVer12) .OR. ;
		(nModulo <> 23 .AND. !IsInCallStack("Crd240Criterio") .AND. lFtvdVer12)
			
		//Faz 2 iteracoes para tentar buscar o pereco do produto.
		//A primeira vez tenta buscar o preço considerando a tabela selecionado pelo usuario na tela caso ele altera a tabela de preco através das teclas [Ctrl + C] 
		//Na segunda vez tenta buscar o preço considerando a tabela padrao MV_TABPAD
		While nIteracao <= 2
					
			If lECCia .AND. lLj901APrc         
        		lRet := Lj901APrc( @nPrecoTab)
        		LjGrvLog("", "Validando preço sem cenário de vendas 1 " + cValToChar(nPrecoTab) + " Retorno " + cValToChar(lRet))        		       		
        		Exit
        	EndIf
			
			DbSelectArea( "SB0" )
			DbSetOrder( 1 )  
			
	        If lTabIPI 
	        	cTabPad := "112"//AllTrim(SuperGetMV("MV_LJECOMT",,SuperGetMV("MV_TABPAD")))
	        Else
	        	If nIteracao == 2
	        		cTabPad := SuperGetMV("MV_TABPAD")
	        	Else
					cTabPad := Lj7DefTab()						        	
	        	EndIf
	        EndIf
			
			If SB0->(FieldPos("B0_PRV" + cTabPad)) > 0		
				nPrecoTab := LjXETPreco(cProduto, cCliente, cLoja, nMoeda, Nil, cTabPad) 
				
				/*
				DbSelectArea("DA1")
				DbSetOrder(1)
				If DbSeek(xFilial("DA1") + cTabPrecos + cProduto)
					nPrecoTab := DA1->DA1_PRCVEN
				EndIf
				*/
								
			Else         
				MsgAlert("Tabela de preco invalida no parametro MV_TABPAD") //"Tabela de preco invalida no parametro MV_TABPAD"
				lRet := .F.
				Exit
			EndIf
	
			If lRet .And. nPrecoTab == 0
				DbSelectArea("SB0")
				DbSetOrder(1)
				If !(DbSeek( xFilial("SB0") + cProduto) )
					Help( " ", 1, "NOPRECO" )
					lRet := .F.
					Exit
			        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			        //³Valida para alguns estados se aceita produto sem preco³
			        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Else
					If LjAnalisaLeg(2)[1] .AND. lRet .AND. &("SB0->B0_PRV"+ cTabPad) == 0 
						If !LjProdGar(cProduto,cTabPad) // verifica se a garantia, caso sim,cadastra o preco e libera
							If nIteracao == 2												
						    	LjMsgLeg(LjAnalisaLeg(2))	   
						    	lRet := .F.
						    Else
								nIteracao++
								Loop
						    EndIf
		                EndIf
					Else
						Exit
					EndIf
				EndIf
			Else
				Exit
			EndIf
		
		End
		
	Else
		If nModulo = 12
			DbSelectArea("SB1")
			SB1->( DbSetOrder(1) )	//B1_FILIAL + B1_COD
			If SB1->( DbSeek(xFilial("SB1") + cProduto) )
				If lECCia .AND. lLj901APrc  
        
        			lRet := Lj901APrc( @nPrecoTab)
        			LjGrvLog("", "Validando preço sem cenário de vendas 2 " + cValToChar(nPrecoTab) + " Retorno " + cValToChar(lRet))
				
				ElseIf  lECommerce .AND. !lECCia  //Obter o preco da Tabela e-Commerce
				    SB0->( DbSetOrder(1) )  //B0_FILIAL+B0_COD
				    If  SB0->( DbSeek(xFilial("SB0")+cProduto) )
						cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,SuperGetMV("MV_TABPAD")))
						nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
					EndIf	
				Else
					nPrecoTab := SB1->B1_PRV1
					If nPrecoTab == 0
					    nPrecoTab := LjGetB0Prv(cProduto, cTabPrecos)
					EndIf
				EndIf	
			EndIf
		Else
			lProdON := lProdON .Or. SuperGetMV("MV_LJPRDON", ,.F.)
			DbSelectArea("SBI")
			DbSetOrder(1)
			If DbSeek(xFilial("SBI")+cProduto)
				nPrecoTab := SBI->BI_PRV
			ElseIf nModulo == 23 .And. lProdON	//Verifica se esta ativa no Front, a Consulta on-line de Produtos direto na retaguarda
				cTabPrecos := AllTrim(SuperGetMv("MV_TABPAD"))
				DbSelectArea("SB0")
				DbSetOrder(1)
				If DbSeek(xFilial("SB0")+cProduto)
					If  lECommerce //Obter o preca da Tabela e-Commerce
						cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,SuperGetMV("MV_TABPAD")))
						nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
					Else
						nPrecoTab := SB0->(&("B0_PRV"+AllTrim(cTabPrecos))) 
					EndIf	
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

If ( nPrecoTab > 0 .And. ( (lECommerce .and. lMvLjIPEn .AND. !lECCia)  .Or. lTabIPI)) .And. !IsInCallStack("LJ861JBPC")
	aAreaSB1 := SB1->(GetArea())                                                                                                                                         
	
		If SB1->(DbSeek(xFilial("SB1")+cProduto ) ) .AND. SB1->B1_IPI > 0 
			//Busca na TES de pedido se está sinalizado para calcular IPI				
			aAreaSF4 := SF4->(GetArea())
			//Busca a TES do Item		 				
			   
			SF4->(DbSetOrder(1)	)
			If SF4->(DbSeek(xFilial("SF4") + cTES ))  .AND. SF4->(!Empty(F4_IPI) .AND. F4_IPI <> "N") 

				//Abate o IPI do Preco Cheio do Produto
           						
        			nValIPIEn := ljfnEGetIpi(nPrecoTab, nCasasIPI, lMVRNDIPI)
        			
        			nPrecoTab -=  nValIPIEn
					
					nValIpiEC :=  nValIPIEn								
			
			EndIf				
			
			RestArea(aAreaSF4)   
			
		EndIf			
	RestArea(aAreaSB1)	
	
EndIf   

RestArea(aArea)
	
Return lRet

Static Function XLjxeTPreco(cProduto, cCliente, cLoja, nMoeda, ;
							nQtdade, cTabPadIn)

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local nRet 			:= 0							//variavel de retorno do preco
Local cTabPrecos    := ""//LjXETabPre(cCliente,cLoja)	//parametro da tabela de preco padrao
Local nPosQuant		:= 0	// Posicao da Quantidade
Local nPosVlUnit	:= 0	// Posicao do Valor unitario do item
Local nPosProd		:= 0	// Posicao do Codigo do Produto
Local nPosItCob		:= 0
Local nPosEnvelo    := 0                            // Posicao do codigo do envelope
Local cMvLjTGar		:= SuperGetMV("MV_LJTPGAR",,"GE")	// Tipo de Garantia Estendida
Local nX			:= 0								// Variavel de controle de For
Local aValores		:= {}								// 
Local cMvLjRetVl	:= SuperGetMV("MV_LJRETVL",,"3") // 1=Retorna o menor preco de uma tabela | 2=Retorna o maior preco de uma tabela | 3=Considera preco da tabela configurada no parametro MV_TABPAD
Local lGE			:= FindFunction("LjUP104OK") .AND. LjUP104ok() // ValidaÃ§Ã£o do Conceito Garantia Estendida 

Local lSFinanc		:= FindFunction("Lj7SfTela") .AND. AliasIndic("MG8") .AND. SuperGetMV("MV_LJCSF",,.F.)// ValidaÃ§Ã£o do Conceito Servico Financeiro
Local cMvLjTSF		:= SuperGetMV("MV_LJTPSF",,"SF")	// Tipo de servico financeiro
Local aRet:={} // retorno preco servico

Local cTabPad		:= ""//Alltrim(SuperGetMv("MV_TABPAD"))

Default nQtdade 	:= 1 
Default cTabPadIn	:= IIF(nModulo == 23,SuperGetMv("MV_TABPAD"),Lj7DefTab())

If Empty(M->LQ_XTAB)
	cTabPrecos := LjXETabPre(cCliente,cLoja)
	cTabPad    := Alltrim(SuperGetMv("MV_TABPAD"))
Else
	cTabPrecos := M->LQ_XTAB
	cTabPad    := M->LQ_XTAB
EndIf
                            
//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„
//Â³SigaPhoto e produto for uma revelacao, o valor unitario |
//Â³vira das funcoes especificas do SigaPhoto.              |
//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„
If nModulo == 72
       nPosVlUnit          := aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]   
       nPosEnvelo          := Ascan(aPosCpoDet, { |x| Upper (Alltrim (x[1])) == "LR_ENVELO"})               

       If SB1->(FieldPos("B1_ESPECIF")) > 0  .AND. nPosEnvelo > 0
             If ALLTRIM(SB1->B1_ESPECIF) == "R" 
                    nRet := aCols[n][nPosVlUnit]                
             EndIf
       Else
             Conout("Para utilizaÃ§Ã£o do modulo SIGAPHOTO Ã© necessario a criaÃ§Ã£o dos campos B1_ESPECIF e LR_ENVELO.") //"Para utilizaÃ§Ã£o do modulo SIGAPHOTO Ã© necessario a criaÃ§Ã£o dos campos B1_ESPECIF e LR_ENVELO."
       EndIf
EndIf

//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
//Â³Verifica preÃ§o do produto de Garantia ou ServiÃ§o.Â³
//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
If nRet == 0 
	If lGE .AND. (nModulo == 12) .AND. (SB1->B1_TIPO == cMvLjTGar)  .AND. FindFunction("Lj7ImpVlr")
		nRet   := Lj7ImpVlr(cProduto,NIL,NIL, cCliente, cLoja, nMoeda) 				          
	ElseIf lSFinanc .AND. (nModulo == 12) .AND. (SB1->B1_TIPO == cMvLjTSF)
		MG8->(DbSetOrder(2))
		 
		If (MG8->(DbSeek(xFilial("MG8")+cProduto)) .AND. MG8->MG8_TPXPRD == "1")
			nPosQuant	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]	// Posicao da Quantidade
			nPosVlUnit	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]	// Posicao do Valor unitario do item
			nPosProd	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})][2]	// Posicao do Codigo do Produto
			nPosItCob	:= IIf(SLR->(FieldPos("LR_ITEMCOB")) > 0, aScan(aPosCpo,{|x| Upper(Alltrim(x[1])) == "LR_ITEMCOB"}) ,0)
					
			//Servico financeiro - Carrega Preco									
			If aCols[n][nPosVlUnit] == 0 .AND. nPosItCob > 0 .AND. !Empty(aCols[n][nPosItCob]) 				 				
				nRet:= LjSfVl(cProduto,0,aCols[Val(aCols[n][nPosItCob])][nPosVlUnit], @aRet, .F., aCols[Val(aCols[n][nPosItCob])][nPosProd])				
			Else
				nRet:= aCols[n][nPosVlUnit]*aCols[n][nPosQuant]
			EndIf					
		EndIf						          
	EndIf
	
	If nRet == 0
		//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
		//Â³Verifica o se esta ativo o Cenario de VendasÂ³
		//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
		If lCenVenda	
			//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
			//Â³Considerada sempre a quantidade 1                           Â³
			//Â³retorna o valor convertido pela moeda da tabela de preco DA1Â³
			//Â³se nao encontrar tabela de preco, retorna valor do B0_PRN   Â³
			//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
			If cMvLjRetVl == "3"
				
				nRet := XMaTabPrVen(	cTabPad,		cProduto,		1,				cCliente,; 
								cLoja,  		nMoeda, 	/*dDataVld*/,	/*nTipo*/,;
								/*lExec*/)
			EndIf						
			
			If cMvLjRetVl <> "3" .OR. nRet == 0
				nRet := XMaTabPrVen(	cTabPrecos,		cProduto,		1,				cCliente,; 
								cLoja,  		nMoeda, 	/*dDataVld*/,	/*nTipo*/,;
								/*lExec*/)
			EndIf		
			
		Else                                                      
			nRet := Posicione("SB0",1,xFilial("SB0")+cProduto,"SB0->B0_PRV"+cTabPadIn)
		EndIf 
	   

		//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
		//Â³Apos verificar a variavel estatica, analisa se existe mais de Â³
		//Â³uma tabela de preco ativa. Agora, verifica no MaTabPrVen      Â³
		//Â³se existe preco para esse produto                             Â³
		// Chama a funÃ§Ã£o ljFilTab para filtrar e processar somente as
		// ativas. Havia situaÃ§Ãµes onde havia 300 tabelas de preco, mas apenas
		// 20 ativas, o que gerava demora na busca do preÃ§o
		//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
		If Len(aTabsPrecos) > 0
			ljFilTab(@aTabsPrecos,cProduto,nQtdade)
		EndIf
		
		For nX := 1 To Len(aTabsPrecos)
			nRet := xMaTabPrVen(	aTabsPrecos[nX], cProduto, 	nQtdade,		cCliente	,; 
								cLoja,  		 nMoeda, 	/*dDataVld*/,	/*nTipo*/	,;
								/*lExec*/)				
			//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
			//Â³Armazena no array aValores os possiveis valores para ser Â³
			//Â³praticado para um produto. Esse array sera utilizado paraÂ³
			//Â³avaliar, caso o produto pertenca a mais de uma tabela de Â³
			//Â³preco, para saber qual sera praticada.                   Â³
			//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
			If nRet > 0
				aAdd(aValores,nRet)
			EndIf
		Next nX	
		//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
		//Â³Sendo o aValores maior que um, significa que existe mais de Â³
		//Â³um preco possivel para um unico produto na venda            Â³
		//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
		If Len(aValores) > 0
			//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
			//Â³Retornando os valores, ordena do menor para o maior para Â³
			//Â³ser tomada a decisao posteriormente                      Â³
			//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
			aSort(aValores)
			//ÃšÃ„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Â¿
			//Â³Verifica o parametro MV_LJRETVL e caso esteja "1"      Â³
			//Â³signiifca que utilizara o menor preco encontrado. Caso Â³
			//Â³contrario, utiliza o maior preco.                      Â³
			//Ã€Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã„Ã™
	  		If cMvLjRetVl == "1"
	  			nRet := aValores[1]
	  		Else
				nRet := aValores[Len(aValores)]	  				
	  		EndIf
		EndIf	
	
	EndIf 
Else                                                      
	nRet := Posicione("SB0",1,xFilial("SB0")+cProduto,"SB0->B0_PRV"+cTabPadIn) 
EndIf

Return nRet

Static Function XLJ7Detalhe(lCalcImpsV, lAlterProd,lValidCli, cCpoOrigem, lIsRecCP, nVlrRecCP, lReproVlIt)

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local nPosItem		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ITEM"})][2]			// Posicao do numero do item
Local nPosProd		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})][2]		// Posicao da codigo do produto
Local nPosQuant		:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]		// Posicao da Quantidade
Local nPosVlUnit	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]		// Posicao do Valor unitario do item
Local nPosVlItem	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VLRITEM"})][2]		// Posicao do Valor do item
Local nPosValDesc	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VALDESC"})][2]		// Posicao do valor de desconto
Local nPosDtItem	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_ITEM"})					// Posicao do numero do item
Local nPosDtProd	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})				// Posicao do Codigo do produto
Local nPosDtTes		:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TES"})					// Posicao do Codigo do TES
Local nPosDtCF		:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_CF"})						// Posicao do Codigo do CF 
Local nPosDtBIcm	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_BASEICM"})				// Posicao da Base de ICM
Local nPosDtVIcm	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALICM"})					// Posicao do Valor do ICM
Local nPosDtVIpi	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALIPI" })				// Posicao do Valor do IPI
Local nPosDtVIss 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALISS" })				// Posicao do Valor do ISS
Local nPosDtTabela	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TABELA" })				// Posicao da Tabela de precos
Local nPosDtDProp	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DESCPRO" })				// Posicao do Desconto proporcional
Local nPosDtPrcTab  := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_PRCTAB"})					// Posicao do Preco de Tabela
Local nPosDtFrete	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALFRE" })				// Posicao do Valor do frete do item
Local nPosDtSeguro 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_SEGURO"})					// Posicao do Valor do Seguro do item
Local nPosDtDespesa	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DESPESA"})				// Posicao do Valor das desepesas acessorias do item
Local nPosDtReserva	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_RESERVA"})				// Posicao do codigo da reserva
Local nPosDtLojaRes	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOJARES"})				// Posicao do Loja da reserva
Local nPosDtOrcRes 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_ORCRES" })				// Posicao do orcamento da reserva
Local nPosDtEmpRes 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_EMPRES" })				// Posicao do codigo da empresa da reserva
Local nPosDtFilRes 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_FILRES" })				// Posicao do codigo da filial da empresa da reserva
Local nPosDtLocal  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOCAL" })					// Posicao do local (armazem)
Local nPosNSerie   	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_NSERIE" })				// Posicao do Numero de serie
Local nPosLoteCTL  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOTECTL" })				// Posicao do Sub Lotermazem)
Local nPosNLote    	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_NLOTE" })					// Posicao do Lote            
Local nPosDtValid  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DTVALID"})				// Posicao da Data de validade do Lote
Local nPosLocaliz  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOCALIZ"})				// Posicao do Localizacao    
Local nPosValePre  	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALEPRE"})					// Posicao do Vale Presente
Local nPosTurno	 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TURNO"})					// Posicao do codigo da reserva
Local nPosCodLan 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_CODLAN"})					// Posicao do codigo da reserva
Local nPosDescIcm 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DESCICM"})					// 
Local nPosMotdIcm 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_MOTDICM"})					//
Local nPos			:= 0							  												// Auxiliar para localizacao em arrays
Local cTesPad		:= ""																			// Codigo do Tes de saida
Local cEstado 		:= SuperGetMv("MV_ESTADO")			       									   	// Identifica o estado da empresa//filial
Local lLinOk        := .F.                 			   											   	// Identifica se a funcao foi chamada pela LINOK ou pela DELOK.
Local nMoedaPrv		:= 0																		   	// Moeda da tabela de preco selecionada
Local cTesSai		:= SuperGetMV("MV_TESSAI",,"501")											   	// Pega do parametro o TES padrao para saida
Local cTesInt		:= ""																			// Codigo do Tes de saida
Local nPrecoTab		:= 0																			// Varivel para armazenar o preco da tabela
Local cTurnoPad		:= SuperGetMv("MV_LJTURNO",,"M")												// Pega o turno padrao
Local nTipoTes		:= 0
Local cCodTes		:= ""
Local cB1Tes		:= ""
Local cSerie		:= "" 
Local aTmpColsD    	:= {} 						       											    // Possui aColsDet Zerado
Local aImps			:= {}
Local nX			:= 0
Local lTefPendCS	:= .F.
Local aTefBKPCS		:= {}
Local cSeekSB8		:= ""
Local cComparaSB8	:= ""
Local nSaldoSB8		:= 0
Local cTmpHas		:= ""
Local nPosHas		:= 0
Local cImps			:= ""
Local aAreaSB1		:= {}
Local lCalcIPI      :=  .T.
Local nPrcUnit 		:= 0
Local nValMerc		:= 0
Local lLj7Tabela	:= IsInCallStack("LJ7TABELA")
Local nQtde 		:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Localizacoes  ³
//³Chile,Colombia  - F1CHI		³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lLocR5		:= GetRpoRelease() >= "R5" .AND. 	cPaisLoc$"CHI|COL" 
Local cMvDescSai	:= SuperGetMV("MV_DESCSAI",,"1")		// Desconto tratamento localizacoes
Local lCAT83		:= SF4->(FieldPos("F4_CODLAN")) > 0 .AND. ;
					   FindFunction("FISA023") 			.AND. ;
					   SuperGetMV("MV_CAT8309",,.F.) //Valida Cat83

Local aDadosCfo     	:= {}
Local nRecSF4			:= 0	
Local lSFinanc    	:= AliasIndic("MG8") .AND. SuperGetMV("MV_LJCSF",,.F.)	// Valida implementação do servico financeiro
Local cMvLjTSF		:= SuperGetMV("MV_LJTPSF",,"SF")	// Tipo Servico Financeiro
Local lRecalcFis	:= .F.
Local cTpFrete 		:= ""
Local lIntSynt 	 	:= SuperGetMV("MV_LJSYNT",,"0") == "1"	 // Informa se a integracao Synthesis esta ativa	

Default lCalcImpsV := .T.																			// Determina se os impostos variaveis devem ser recalculados 
Default lAlterProd := .F.																			// Indica que eh alteracao do produto
Default lValidCli  := .F. 
Default cCpoOrigem := ""
Default lIsRecCP   := .F. 			//Indica que eh produto de Recarga de Cartao Presente (Gift Card)
Default nVlrRecCP  := 0 			//Valor da Recarga de Cartao Presente (Gift Card)
Default lReproVlIt := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento da funcao que podera ser chamada pela LinOk() ³
//³A funcao &(Readvar()) nao pode ser executada n LinOk().  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ("LJ7LINOK" $ ProcName(1)) .OR. ("LJ7VALDEL" $ ProcName(1)) .OR. ("LINHAOK" $ ProcName(4))
	lLinOk	:= .T.
Endif	
																
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Funcao utilizada para verificar a ultima versao dos fontes      ³
//³ SIGACUS.PRW, SIGACUSA.PRX e SIGACUSB.PRX, aplicados no rpo do   |
//| cliente, assim verificando a necessidade de uma atualizacao     |
//| nestes fontes. NAO REMOVER !!!							        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF !(FindFunction("SIGACUS_V") .AND. SIGACUS_V() >= 20050512)
    Final("Atualizar SIGACUS.PRW !!!")
Endif
IF !(FindFunction("SIGACUSA_V") .AND. SIGACUSA_V() >= 20050512)
    Final("Atualizar SIGACUSA.PRX !!!")
Endif
IF !(FindFunction("SIGACUSB_V") .AND. SIGACUSB_V() >= 20050512)
    Final("Atualizar SIGACUSB.PRX !!!")
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiona os arquivos para a rotina                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(DbSetOrder( 1 ))
SB1->(DbSeek( xFilial("SB1") + aCols[n][nPosProd] ))

SB0->(DbSetOrder( 1 ))
SB0->(DbSeek( xFilial("SB0") + aCols[n][nPosProd] ))


//Tratamento ExecAuto: Se TES informada, considera TES recebida
If lAutoExec .AND. (Len(aColsDet) >= n) .AND. !Empty(aColsDet[n][nPosDtTes])
	cTesPad := aColsDet[n][nPosDtTes]
Else
	//---
	// PRIORIDADE: TES INTELIGENTE (SFM)
	// Parametro da funcao MaTESInt
	// ExpN1 = Documento de 1-Entrada / 2-Saida
	// ExpC1 = Tipo de Operacao Tabela "DF" do SX5
	// ExpC2 = Codigo do Cliente ou Fornecedor
	// ExpC3 = Codigo do gracao E-Entrada
	// ExpC4 = Tipo de Operacao E-Entrada
	//---
	cTESInt := MaTesInt( 2	, "01"				, M->LQ_CLIENTE, M->LQ_LOJA,;
						"C"	, aCols[n][nPosProd], NIL )						
	If !Empty(cTesInt)
		cTesPad := cTesInt	
	Else
		//obtemos o TES padrao
		cTesPad := IIf( Empty( RetFldProd(SB1->B1_COD,"B1_TS") ), cTesSai, RetFldProd(SB1->B1_COD,"B1_TS") )
		
		//caso seja Servicos Financeiros, subtituimos o TES padrao
	 	If lSFinanc .AND. SB1->B1_TIPO == cMvLjTSF
			MG8->( dbSetOrder(2) )
			If MG8->( DbSeek(xFilial("MG8") + aCols[n][nPosProd]) )
				cTesPad := MG8->MG8_TESSB1
			EndIf
		EndIf	
	EndIf
EndIf

SF4->( DbSeek(xFilial("SF4")+cTesPad) )
SA1->( DbSetOrder(1) )
SA1->( DbSeek(xFilial("SA1") + M->LQ_CLIENTE + M->LQ_LOJA) )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o produto ja esta no array de detalhes                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPos := If( n>Len(aColsDet), nPos:=0, nPos:=n )
If nPos == 0
	If !(MafisFound())
		lCalcIPI    := Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALIPI"})	 > 0
	
		cTpFrete := Lj7TpFrete(Nil,Nil)
		MaFisIni( M->LQ_CLIENTE, M->LQ_LOJA, "C" , "S" , ;
		          NIL          , NIL        , NIL , .F., ;
		          "SB1"        , cNomeProg  , NIL , NIL, ;
		          NIL          , NIL        , NIL , NIL, ;
		          NIL          , NIL        , NIL , lCalcIPI,; 
		          NIL          , NIL        , NIL , NIL, ;
		          NIL          , cTpFrete )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³SigaPhoto - Inicializa campos do aColsDet.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nModulo == 72 
		// Carrega aColsDet vazio.
		aTmpColsD := KDaColsDet()
		
		AAdd( aColsDet, aTmpColsD[1] )
	Else
		aAdd( aColsDet, Array( Len(aHeaderDet)+1 ) )
	EndIf
		
	nPos	:= Len( aColsDet )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Quando for inclusao de um novo item chama a funcao MafisAdd              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lFtvdVer12
		MaFisAdd( aCols[n][nPosProd],;			// Produto
					cTesPad,;					// Tes
					aCols[n][nPosQuant],;		// Quantidade
					aCols[n][nPosVlUnit],;		// Preco unitario
					aCols[n][nPosValDesc],;		// Valor do desconto
					"",; 						// Numero da NF original
					"",; 						// Serie da NF original
					0,;							// Recno da NF original
					0,; 						// Valor do frete do item
					0,; 						// Valor da despesa do item
					0,; 						// Valor do seguro do item
					0,; 						// Valor do frete autonomo
					aCols[n][nPosVlItem] + IIf(cPaisLoc == "BRA", aCols[n][nPosValDesc], 0),;		// Valor da mercadoria
					0 )							// Valor da embalagem			

	ElseIf lFtvdVer12	.And. !Empty(aCols[n][nPosProd])		
		MaFisIniLoad(	n								,;	//Numero do Item no Acols
						{aCols[n][nPosProd]			,;	//IT_PRODUTO
						cTesPad						,; 	//IT_TES
						SB1->B1_CODISS				,; 	//IT_CODISS
						aCols[n][nPosQuant]			,;	//IT_QUANT
						""								,; 	//IT_NFORI
						""								,; 	//IT_SERIORI
						SB1->(RecNo())				,;	//IT_RECNOSB1
						SF4->(RecNo())				,;	//IT_RECNOSF4
						0  							}) 	//IT_RECORI
		
		
		MaFisLoad("IT_VALMERC"	,aCols[n][nPosVlItem] + IIf(cPaisLoc == "BRA", aCols[n][nPosValDesc], 0)	, n) 
		MaFisLoad("IT_PRCUNI"	,aCols[n][nPosVlUnit] , n)        
		MaFisLoad("IT_DESCONTO"	,aCols[n][nPosValDesc], n)
		MaFisLoad("IT_FRETE"	,0	,n)			
		MaFisLoad("IT_SEGURO"	,0	,n)
		MaFisLoad("IT_DESPESA"	,0	,n)			
	
		MaFisRecal("",n)
		
		MaFisEndLoad(n,2)	 
	EndIf
	
	If cPaisLoc <> "BRA" .And. Len(aCols) > 1
		Lj7AtuDesc()
	EndIf
	
Else

	If lFtvdVer12

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Chama a funcao MaFisAlt somente quando for alteracao de algum produto.   ³
		//³ Cuidado com a alteracao destas linhas pois afeta diretamente quando eh   ³
		//³ utilizado descontos no item e total dos produtos                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
		cTesPad := IIf("LR_PRODUTO" $ ReadVar() .OR. "LQ_CLIENTE" $ ReadVar(),cTesPad,aColsDet[nPos][nPosDtTes])
	
		SF4->(DbSeek(xFilial("SF4")+cTesPad))
	
   		nRecSF4	:= SF4->( RecNo() )
	
		If n == 1 .And. !Empty(aCols[n][nPosProd])
			MaFisIniLoad(	n							,;	//Numero do Item no Acols
							{aCols[n][nPosProd]			,;	//IT_PRODUTO
							cTesPad						,; 	//IT_TES
							SB1->B1_CODISS				,; 	//IT_CODISS
							aCols[n][nPosQuant]			,;	//IT_QUANT
							""							,; 	//IT_NFORI
							""							,; 	//IT_SERIORI
							SB1->(RecNo())				,;	//IT_RECNOSB1
							nRecSF4						,;	//IT_RECNOSF4
							0  								}) 	//IT_RECORI
		EndIf
		
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chama a funcao MaFisAlt somente quando for alteracao de algum produto.   ³
	//³ Cuidado com a alteracao destas linhas pois afeta diretamente quando eh   ³
	//³ utilizado descontos no item e total dos produtos                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 	If MaFisFound("IT",n) .AND. ( lCalcImpsV .OR. cPaisLoc == "BRA" )
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A funcao Lj7TotImpsV() eh chamada nesse ponto para que o os impostos do produto anterior ³
		//³sejam subtraidos do array com o total dos impostos variaveis...                          ³
		//³A funcao InInCallStack verifica se a rotina Lj7Detalhe foi acionada a partir da troca de ³
		//³tabela de precos (Lj7Tabela)                                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc <> "BRA" .AND.;
			( (ReadVar() $ "M->LR_PRODUTO|M->LR_QUANT|M->LR_VRUNIT|M->LR_VLRITEM|M->LR_DESC|M->LR_VALDESC" .AND. Lj7T_DescV(2) == 0) .OR.;
			lLj7Tabela )
		   	Lj7TotImpsV(n,4)
		EndIf
		
		If cPaisLoc <> "BRA"
		
	 		If "LR_PRODUTO" $ ReadVar()
		 		lAlterProd	:= .T.
	 			//Seta a variavel lRecalcFis para indicar que deve executar o recalculo de tods os itens da MatxFis devido ter alterado o produto, pois os valores nao eram recalculados corretamente dentro da MatxFis
		 		lRecalcFis := If(!lLinOk, &(ReadVar()) <> MaFisRet(n, "IT_PRODUTO"), .F.)
				If !lFtvdVer12
					MaFisLoad("IT_PRODUTO"	,If("LR_PRODUTO"$ReadVar()	,If(!lLinOk,&(ReadVar()),aCols[n][nPosProd])	,aCols[n][nPosProd])	,n)
				ElseIf lFtvdVer12
					MaFisLoad("IT_PRODUTO"	,If("LR_PRODUTO"$ReadVar(), if(!lLinOk,IIf(!lValidCli,&(ReadVar()),aCols[n][nPosProd]),aCols[n][nPosProd])	,aCols[n][nPosProd])	,n)
				EndIf	
			ElseIf "LR_QUANT" $ ReadVar()
		 		lAlterProd	:= .T.
		 		nQtde := If(!lReproVlIt .And. "LR_QUANT"	$ReadVar()	,If(!lLinOk,&(ReadVar()),aCols[n][nPosQuant])	,aCols[n][nPosQuant])
				MaFisLoad("IT_QUANT", nQtde ,n)
				If Len(aCols) > 1
					Lj7AtuDesc()
				EndIf
			ElseIf "LR_VRUNIT" $ ReadVar()
				MaFisLoad("IT_PRCUNI"	,If("LR_VRUNIT"	$ReadVar()	,If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]),aCols[n][nPosVlUnit])	,n)
			ElseIF "LR_VALDESC" $ ReadVar()
				aCols[n][nPosValDesc] := If(!lLinOk,&(ReadVar()),aCols[n][nPosValDesc])
				Lj7AtuDesc()
			ElseIF "LR_DESC" $ ReadVar()
				Lj7AtuDesc()
			Endif
			If lLj7Tabela .OR. (!Empty(ReadVar()) .And. !(ReadVar() $ "M->LR_VALDESC|M->LR_DESC"))
				MaFisLoad("IT_DESCONTO", aCols[n][nPosValDesc], n)
			Endif
			
			MaFisLoad("IT_TES",If("LR_PRODUTO"$ReadVar(),cTesPad,aColsDet[nPos][nPosDtTes]),n)
			
			If lFtvdVer12
				MaFisLoad("IT_RECNOSF4",nRecSF4,n)
			EndIf
			
			If SB1->(FieldPos("B1_IPI")) > 0		
				MaFisLoad("IT_ALIQIPI",SB1->B1_IPI,n)
			EndIf

			If "LR_VLRITEM"$ReadVar() .And. !lLinOk
				nPrcUnit := &(ReadVar())
				nValMerc := &(ReadVar())
			Else
				// usar nPosVlUnit para nPrcUnit e IT_PRCUNI!!
				nPrcUnit := aCols[n][nPosVlUnit]
				nValMerc := aCols[n][nPosVlItem]
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 - Localizacoes                                          ³
			//³Se o parametro MV_DESCSAI estiver igual a 2, definir IT_VALMERC e    ³
			//³IT_PRCUNI com os descontos para os calculos da MATXFIS  				³
			//³Paises:CHILE, COLOMBIA  - F1CHI                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   		If lLocR5 
	   			If cMvDescSai == "2"
					MaFisLoad("IT_PRCUNI",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]),aCols[n][nPosVlUnit]),n) 
					MaFisLoad("IT_VALMERC",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlItem]),aCols[n][nPosVlItem]),n)
				Else
					MaFisLoad("IT_PRCUNI",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),n)
					MaFisLoad("IT_VALMERC",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),n)						
				Endif
				
				If aCols[n][nPosValDesc] > 0
					Lj7DescPro(0, MaFisRet(nPos,"IT_VALMERC") )   
				EndIf
			Else
				If "LR_QUANT" $ ReadVar()
					MaFisLoad("IT_PRCUNI",	nPrcUnit+aCols[n][nPosValDesc] ,n)
					MaFisLoad("IT_VALMERC",	nValMerc+aCols[n][nPosValDesc] ,n)
					MaFisLoad("IT_TES",	 	If("LR_PRODUTO"$ReadVar(),cTesPad,aColsDet[nPos][nPosDtTes]),n)
				Else
					MaFisLoad("IT_PRCUNI",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),n)
					MaFisLoad("IT_VALMERC",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),n)
				EndIf
			EndIf		
			
			If lFtvdVer12
				MaFisLoad("IT_DESCONTO"	,aCols[n][nPosValDesc], n)
				MaFisLoad("IT_FRETE"	,0	,n)			
				MaFisLoad("IT_SEGURO"	,0	,n)
				MaFisLoad("IT_DESPESA"	,0	,n)			
			EndIf
			
			If !IsInCallStack("Lj7ValDel")
				MaFisRecal("",n)  //Recalcula impostos do Item
			  	MaIt2cab()
				If lRecalcFis
					MaFisReprocess(2)
				EndIf
			EndIf
			
		Else
			
	 		If "LR_PRODUTO" $ ReadVar()
		 		lAlterProd	:= .T.
				If !lFtvdVer12
					MaFisAlt("IT_PRODUTO"	,If("LR_PRODUTO"$ReadVar()	,If(!lLinOk,&(ReadVar()),aCols[n][nPosProd])	,aCols[n][nPosProd])	,n)
				ElseIf lFtvdVer12
					MaFisAlt("IT_PRODUTO"	,If("LR_PRODUTO"$ReadVar(), if(!lLinOk,IIf(!lValidCli,&(ReadVar()),aCols[n][nPosProd]),aCols[n][nPosProd])	,aCols[n][nPosProd])	,n)
				EndIf	
			ElseIf "LR_QUANT" $ ReadVar()
		 		lAlterProd	:= .T.
				MaFisAlt("IT_QUANT"		,If("LR_QUANT"	$ReadVar()	,If(!lLinOk,&(ReadVar()),aCols[n][nPosQuant])	,aCols[n][nPosQuant])	,n)
			ElseIf "LR_VRUNIT" $ ReadVar()
				MaFisAlt("IT_PRCUNI"	,If("LR_VRUNIT"	$ReadVar()	,If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]),aCols[n][nPosVlUnit])	,n)
			ElseIF "LR_VALDESC" $ ReadVar()
				aCols[n][nPosValDesc] := If(!lLinOk,&(ReadVar()),aCols[n][nPosValDesc])
				MaFisAlt("IT_DESCONTO"	, aCols[n][nPosValDesc], n)
			ElseIF "LR_DESC" $ ReadVar()
				MaFisAlt("IT_DESCONTO"	, aCols[n][nPosValDesc], n)
			Endif
			If lLj7Tabela .OR. (!Empty(ReadVar()) .And. !(ReadVar() $ "M->LR_VALDESC|M->LR_DESC"))
				MaFisAlt("IT_DESCONTO", aCols[n][nPosValDesc], n)
			Endif
			
			MaFisAlt("IT_TES",If("LR_PRODUTO"$ReadVar(),cTesPad,aColsDet[nPos][nPosDtTes]),n)
			
			If lFtvdVer12
				MaFisAlt("IT_RECNOSF4",nRecSF4,n)
			EndIf
			
			If SB1->(FieldPos("B1_IPI")) > 0		
				MaFisAlt("IT_ALIQIPI",SB1->B1_IPI,n)
			EndIf

			If "LR_VLRITEM"$ReadVar() .And. !lLinOk
				nPrcUnit := &(ReadVar())
				nValMerc := &(ReadVar())
			Else
				// usar nPosVlUnit para nPrcUnit e IT_PRCUNI!!
				If cPaisLoc == "ARG"
					nPrcUnit := aCols[n][nPosVlUnit]
					nValMerc := aCols[n][nPosVlItem]
				Elseif cPaisLoc == "MEX"
					nPrcUnit := aCols[n][nPosVlUnit]
					nValMerc := aCols[n][nPosVlItem]+aCols[n][nPosValDesc]
				Else
					nPrcUnit := aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]
					nValMerc := aCols[n][nPosVlItem]+aCols[n][nPosValDesc]
				EndIf
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 - Localizacoes                                          ³
			//³Se o parametro MV_DESCSAI estiver igual a 2, definir IT_VALMERC e    ³
			//³IT_PRCUNI com os descontos para os calculos da MATXFIS  				³
			//³Paises:CHILE, COLOMBIA  - F1CHI                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   		If lLocR5 
	   			If cMvDescSai == "2"
					MaFisAlt("IT_PRCUNI",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]),aCols[n][nPosVlUnit]),n) 
					MaFisAlt("IT_VALMERC",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlItem]),aCols[n][nPosVlItem]),n)
				Else
					MaFisAlt("IT_PRCUNI",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),n)
					MaFisAlt("IT_VALMERC",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),n)						
				Endif
				
				If aCols[n][nPosValDesc] > 0
					Lj7DescPro(0, MaFisRet(nPos,"IT_VALMERC") )   
				EndIf
			Else
				If cPaisLoc <> "ARG" .Or. ("LR_QUANT" $ ReadVar())
					MaFisAlt("IT_PRCUNI",	nPrcUnit,n)
					MaFisAlt("IT_VALMERC",	nValMerc,n)
					MaFisAlt("IT_TES",	 	If("LR_PRODUTO"$ReadVar(),cTesPad,aColsDet[nPos][nPosDtTes]),n)
				Else
					MaFisAlt("IT_PRCUNI",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),aCols[n][nPosVlUnit]+aCols[n][nPosValDesc]),n)
					MaFisAlt("IT_VALMERC",	If("LR_VLRITEM"$ReadVar(),If(!lLinOk,&(ReadVar()),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),aCols[n][nPosVlItem]+aCols[n][nPosValDesc]),n)
				EndIf
			EndIf		
			
			If lFtvdVer12
				
				MaFisLoad("IT_DESCONTO"	,aCols[n][nPosValDesc], n)
				MaFisLoad("IT_FRETE"	,0	,n)			
				MaFisLoad("IT_SEGURO"	,0	,n)
				MaFisLoad("IT_DESPESA"	,0	,n)			
		
				MaFisRecal("",n)
					
			EndIf
			
		EndIf
		
	ElseIf !MaFisFound("IT",n) .AND. lAutoExec 	
		If !(MafisFound())

			cTpFrete := Lj7TpFrete(M->LQ_CLIENTE,M->LQ_LOJA)
			MaFisIni( M->LQ_CLIENTE, M->LQ_LOJA, "C" , "S" , ;
			          M->LQ_TIPOCLI , NIL        , NIL , .F., ; 
			          "SB1"        , "LOJA701"  , NIL , NIL, ;
			          NIL          , NIL        , NIL , NIL, ;
			          NIL          , NIL        , NIL , lCalcIPI,;
			          NIL          , NIL        , NIL , NIL, ;
			          NIL          , cTpFrete)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Quando for inclusao de um novo item chama a funcao MafisAdd              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaFisAdd( aCols[n][nPosProd],;			// Produto
					cTesPad,;					// Tes
					aCols[n][nPosQuant],;		// Quantidade
					aCols[n][nPosVlUnit],;		// Preco unitario
					aCols[n][nPosValDesc],;		// Valor do desconto
					"",; 						// Numero da NF original
					"",; 						// Serie da NF original
					0,;							// Recno da NF original
					0,; 						// Valor do frete do item
					0,; 						// Valor da despesa do item
					0,; 						// Valor do seguro do item
					0,; 						// Valor do frete autonomo
					aCols[n][nPosVlItem] + IIf(cPaisLoc == "BRA", aCols[n][nPosValDesc], 0),;		// Valor da mercadoria
					0 )							// Valor da embalagem			
	
	
		
	Endif
Endif

aColsDet[nPos][nPosDtItem] 	    := aCols[n][nPosItem]
aColsDet[nPos][nPosDtProd] 	    := aCols[n][nPosProd]
aColsDet[nPos][nPosDtTes]	 	:= If(Empty(aColsDet[nPos][nPosDtTes]),cTesPad,IIf("LR_PRODUTO" $ ReadVar(),cTesPad,aColsDet[nPos][nPosDtTes]))
aColsDet[nPos][nPosDtCF]		:= If(MaFisFound("IT",n),MaFisRet(n,"IT_CF"),aColsDet[nPos][nPosDtCF])

If cPaisLoc == "BRA"
   If nPosDtVIpi > 0
      aColsDet[nPos][nPosDtVIpi]		:= If(MaFisFound("IT",n),MaFisRet(n,"IT_VALIPI"),Nil)
   EndIf

   If aColsDet[nPos][nPosDtCF] != NIL
		If Left(aColsDet[nPos][nPosDtCF],4) == "6405"	
			aColsDet[nPos][nPosDtCF] := "6404"+SubStr(aColsDet[nPos][nPosDtCF],5,Len(aColsDet[nPos][nPosDtCF])-4)		
   		EndIf
   EndIf
   		
   If MaFisFound("IT",n)
		If MaFisRet(n,"IT_VALICM") > 0
			aColsDet[nPos][nPosDtBIcm]	:= MaFisRet(n,"IT_BASEICM")
			aColsDet[nPos][nPosDtVIcm]	:= MaFisRet(n,"IT_VALICM")
			
			If MaFisRet(n,"IT_DEDICM") > 0 .And. nPosDescIcm > 0 .And. nPosMotdIcm > 0
				aColsDet[nPos][nPosDescIcm]	:= MaFisRet(n,"IT_DEDICM")
				aColsDet[nPos][nPosMotdIcm]	:= MaFisRet(n,"LF_MOTICMS")
			EndIf
		Endif	  
		If MaFisRet(n,"IT_VALISS") > 0
			aColsDet[nPos][nPosDtVIss] := MaFisRet(n,"IT_VALISS")
		EndIf
   Endif   
ElseIf cPaisLoc <> "BRA" .AND. lFtvdVer12		
	aColsDet[nPos][nPosDtCF]	:= If(MaFisFound("IT",n),MaFisRet(n,"IT_CF"),aColsDet[nPos][nPosDtCF])
EndIf   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz a busca do Armazem somente quando se digita o codigo³
//³do produto.                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( "M->LR_PRODUTO" $ Readvar()) .OR. (Type("M->LQ_PRODUTO") == "C" .AND. ( "M->LQ_PRODUTO" $ Readvar()))
	If !(lAutoExec .AND. !Empty(aColsDet[nPos][nPosDtLocal]) )		// Respeita o enviado pela ExecAuto	
		aColsDet[nPos][nPosDtLocal]	    := Iif(Empty(SB1->B1_COD),aColsDet[nPos][nPosDtLocal],RetFldProd( SB1->B1_COD,"B1_LOCPAD")) 
	EndIf	
EndIf
                        
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Para localizacoes, somente zera o desconto quando for alteracao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "BRA" .OR. lCalcImpsV	
	aColsDet[nPos][nPosDtDProp]	    := 0 // Implementar o desconto proporcional
EndIf

If lCenVenda
	aColsDet[nPos][nPosDtTabela]  := LjXETabPre(M->LQ_CLIENTE,M->LQ_LOJA)
	cTabPreco := aColsDet[nPos][nPosDtTabela]
ElseIf lLj7Tabela .OR. Empty(aColsDet[nPos][nPosDtTabela])
	aColsDet[nPos][nPosDtTabela]  := cTabPad
	cTabPreco := cTabPad
Else
	cTabPreco := aColsDet[nPos][nPosDtTabela]
EndIf
       
If lIsRecCP //Recarga de Cartao Presente (Gift Card)
	If aColsDet[nPos][nPosDtPrcTab] == NIL .OR. lAlterProd
		aColsDet[nPos][nPosDtPrcTab] := nVlrRecCP //Considera como preco, o valor informado no TEF no momento da Recarga do Cartao Presente (Gift Card)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³SIGAPHOTO - O preco de venda sempre retorna da funcao LjxeValPre, porque dentro dela ja a a validacao para Cenario de Vendas.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf nModulo == 72
	LjxeValPre (@nPrecoTab	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
				nMoedaCor	, If("LR_QUANT"$ReadVar(),&(ReadVar()),aCols[n][nPosQuant]) )
	aColsDet[nPos][nPosDtPrcTab]	:= nPrecoTab
ElseIf !lIntSynt .AND. !(lAutoExec .AND. !Empty(aColsDet[nPos][nPosDtPrcTab]) )
	If lCenVenda
		If (!Empty(aCols[n][nPosProd]) .AND. lFTVDVer12) .OR. !lFTVDVer12 
			LjxeValPre (@nPrecoTab	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
						nMoedaCor	, If("LR_QUANT"$ReadVar(),&(ReadVar()),aCols[n][nPosQuant]) )
			aColsDet[nPos][nPosDtPrcTab]	:= nPrecoTab
		EndIf
	Else                    
	    If SB0->(FieldPos("B0_PRV"+cTabPreco)) > 0   
			If SB0->(FieldPos("B0_MOEDA" + cTabPreco)) > 0
				nMoedaPrv := Max(&("SB0->B0_MOEDA" + cTabPreco),1)
				aColsDet[nPos][nPosDtPrcTab]	:= IIf( (cPaisLoc == "ARG" .AND. SB0->&("B0_PRV"+cTabPreco) == 0),aColsDet[nPos][nPosDtPrcTab],;
														A410Arred(xMoeda(&("SB0->B0_PRV" + cTabPreco),nMoedaPrv,nMoedaCor,dDataBase,nDecimais+1,,nTxMoeda),"L2_PRCTAB",nMoedaCor) )
			Else
				//Quando utiliza ExecAuto para gravacao da Venda, considera valor recebido
				If aColsDet[nPos][nPosDtPrcTab] == NIL .OR. (lAlterProd .AND. !lAutoExec)
					If (cPaisLoc == "ARG" .AND. SB0->&("B0_PRV"+cTabPreco) == 0)
						aColsDet[nPos][nPosDtPrcTab]	:= aColsDet[nPos][nPosDtPrcTab]
					ElseIf  !Empty(aCols[n][nPosProd])
						LjxeValPre (@nPrecoTab	, aCols[n][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA	,;
									nMoedaCor	, aCols[n][nPosQuant] )
						aColsDet[nPos][nPosDtPrcTab]	:= nPrecoTab
					Endif	
					
				EndIf
			EndIf
		Endif	
	Endif
EndIf

If aColsDet[nPos][Len(aColsDet[nPos])] == NIL
   aColsDet[nPos][Len(aColsDet[nPos])] := .F.
EndIf   
aColsDet[nPos][nPosDtFrete]	    := If(MaFisFound("IT",n),MaFisRet(n,"IT_FRETE"),Nil)
aColsDet[nPos][nPosDtSeguro]	:= If(MaFisFound("IT",n),MaFisRet(n,"IT_SEGURO"),Nil)
aColsDet[nPos][nPosDtDespesa]	:= If(MaFisFound("IT",n),MaFisRet(n,"IT_DESPESA"),Nil)
aColsDet[nPos][nPosDtReserva]	:= If(Empty(aColsDet[nPos][nPosDtReserva]),Space(TamSx3("L2_RESERVA")[1]),aColsDet[nPos][nPosDtReserva])
aColsDet[nPos][nPosDtLojaRes]	:= If(Empty(aColsDet[nPos][nPosDtLojaRes]),Space(TamSx3("L2_LOJARES")[1]),aColsDet[nPos][nPosDtLojaRes])
aColsDet[nPos][nPosDtOrcRes]	:= If(Empty(aColsDet[nPos][nPosDtOrcRes]),Space(TamSx3("L2_ORCRES")[1]),aColsDet[nPos][nPosDtOrcRes])
aColsDet[nPos][nPosDtFilRes]	:= If(Empty(aColsDet[nPos][nPosDtFilRes]),Space(TamSx3("L2_FILRES")[1]),aColsDet[nPos][nPosDtFilRes])
aColsDet[nPos][nPosDtEmpRes]	:= If(Empty(aColsDet[nPos][nPosDtEmpRes]),Space(TamSx3("L2_EMPRES")[1]),aColsDet[nPos][nPosDtEmpRes])

//Campos da aColsDet que sao alterados durante o processamento
aColsDet[nPos][nPosNSerie]		:= If( Empty(aColsDet[nPos][nPosNSerie]),Space(TamSx3("L2_NSERIE")[1]),aColsDet[nPos][nPosNSerie])
aColsDet[nPos][nPosLoteCTL]	    := If( Empty(aColsDet[nPos][nPosLoteCTL]),Space(TamSx3("L2_LOTECTL")[1]),aColsDet[nPos][nPosLoteCTL])
aColsDet[nPos][nPosNLote]		:= If( Empty(aColsDet[nPos][nPosNLote]),Space(TamSx3("L2_NLOTE")[1]),aColsDet[nPos][nPosNLote])
aColsDet[nPos][nPosDtValid]		:= If( Empty(aColsDet[nPos][nPosDtValid]),CToD('  /  /  '),aColsDet[nPos][nPosDtValid])
aColsDet[nPos][nPosLocaliz]	    := If( Empty(aColsDet[nPos][nPosLocaliz]),Space(TamSx3("L2_LOCALIZ")[1]),aColsDet[nPos][nPosLocaliz])

If nPosValePre > 0
	aColsDet[nPos][nPosValePre]	:= If( Empty(aColsDet[nPos][nPosValePre]),Space(TamSx3("L2_VALEPRE")[1]),aColsDet[nPos][nPosValePre])
EndIf
If nPosTurno > 0 .AND. LJAnalisaLeg(47)[1]
	If Empty(aColsDet[nPos][nPosTurno])
		M->LR_TURNO 				:= cTurnoPad
		aColsDet[nPos][nPosTurno] 	:= cTurnoPad
	EndIf	
EndIf
If lCAT83 .AND. nPosCodLan > 0
	aColsDet[nPos][nPosCodLan] 	:= SF4->F4_CODLAN
EndIf

If cPaisLoc == "ARG" .AND. ReadVar() $ "M->LR_PRODUTO|M->LR_QUANT|M->LR_TES"
	If nPosProd > 0 .AND. nPosLoteCTL > 0 .AND. nPosNLote > 0 .AND. Len(aColsDet) >= n .AND.;
			Len(aColsDet[n]) > nPosLoteCTL .AND. Len(aColsDet[n]) > nPosNLote
		
		aAreaSB1 := SB1->( GetArea() )
		If  Empty(aColsDet[n][nPosLoteCTL]) .AND. Empty(aColsDet[n][nPosNLote])
			SB1->( DbSetOrder(1) )
			If SB1->( DbSeek(xFilial("SB1") + aCols[n][nPosProd]) )
				cB1Tes	:= RetFldProd( SB1->B1_COD, "B1_TS" )
				If Empty( cB1Tes )
					cB1Tes := cTesSai
				EndIf
				If SB1->B1_RASTRO $ "LS"
					cTmpHas := AllTrim(SuperGetMv("MV_IMPSIVA",,"IVA|"))
					nPosHas := AT("|",cTmpHas)
					If nPosHas == 0
						nPosHas := Len(cTmpHas)
					EndIf
					cImps := IIf(Empty(Substr(cTmpHas,nPosHas+1)), "III|IIN", Substr(cTmpHas,nPosHas+1))
					aImps := TesImpInf(cB1Tes)
					For nX := 1 to Len(aImps)
						If aImps[nX][1] $ cImps
							nPosLote        := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_NLOTE"})
							nPosLotCtl      := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOTECTL"})
							nPosDValid      := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DTVALID"})
							nPosPotenc      := 0
							F4Lote( NIL			, NIL						, NIL		, "701A"	,;
									SB1->B1_COD	, aColsDet[n][nPosDtLocal]	, NIL		, NIL		,;
									NIL			, NIL						, .T.		)
							MaFisAlt("IT_QUANT",aCols[n][nPosQuant]+1,n)
							MaFisAlt("IT_QUANT",aCols[n][nPosQuant],n)
							Exit
						EndIf
					Next nX
				EndIf
			EndIf
		EndIf
		RestArea(aAreaSB1)
	EndIf
EndIf
// Valoriza os campos de impostos no aColsDet e atualiza interface com o usuario...
If lCalcImpsV .AND. cPaisLoc <> "BRA" .AND. !aTail(aCols[nPos])
	Lj7RecalImp(nPos,3)
EndIf

Return

Static Function xMaTabPrVen(cTabPreco,cProduto,nQtde,cCliente,cLoja,nMoeda,dDataVld,nTipo,lExec,lAtuEstado,lProspect)

Static cMvEstado
Static cMvNorte

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local aArea     := GetArea()
Local aAreaSB1  := SB1->(GetArea())
Local aStruDA1  := {}

Local cTpOper   := ""
Local cQuery    := ""
Local cAliasDA1 := "DA1"

Local nPrcVen   := 0
Local nResult   := 0
Local nMoedaTab := 1
Local nScan     := 0
Local nY        := 0
Local cMascara  := SuperGetMv("MV_MASCGRD")
Local nTamProd  := Len(SB1->B1_COD)
Local nFator    := 0

Local lUltResult:= .T.
Local lQuery    := .F.
Local nProcessa := 0
Local lGrade    := MaGrade()
Local lGradeReal:= .F.
Local lPrcDA1   := .F.
Local cProdRef  := cProduto
Local lSeekDa1  := .F.
Local lR5      	:= GetRpoRelease("R5")    				// Indica se o release e 11.5
Local lLjcnvB0	:= SuperGetMv("MV_LJCNVB0",,.F.)		// Retorna pre? da SB0 na aus?cia do pre? do Produto na DA0 e DA1
Local lPOS 		:= Iif(FindFunction("STFIsPOS"), STFIsPOS(), .F.) //E Totvs Pdv? 

Local lOM010EST	:= Iif(cPaisLoc != "TRI" .AND. ExistBlock("OM010ESTE",.F.,.F.),.T.,.F.) // PE no qual, atrav? de um retorno l?ico, o cliente seleciona se o estado do cliente ser?o informado no A1_EST ou A1_ESTE. 
Local lSA1EstE	:= .F.

DEFAULT cMvEstado := GetMv("MV_ESTADO")
DEFAULT cMvNorte  := GetMv("MV_NORTE")
DEFAULT nMoeda    := 1
DEFAULT aUltResult:= {}
DEFAULT dDataVld  := dDataBase
DEFAULT nTipo     := 1
DEFAULT lExec     := .T.
DEFAULT lAtuEstado:= .F.
DEFAULT lProspect := .F.

If lAtuEstado
	cMvEstado	:= GetMv("MV_ESTADO")
	cMvNorte	:= GetMv("MV_NORTE")
Endif

If lOM010EST
	lSA1EstE := Execblock("OM010ESTE",.F.,.F.)
	If Valtype(lSA1EstE) != 'L'
		lSA1EstE := .F.
	EndIf
EndIf


If lGrade .And.	MatGrdPrrf(@cProdRef,.T.)
	nTamProd	:= Len(cProdRef)
	lGradeReal	:= .T.
	cProdRef	:= Padr(cProdRef,Len(DA1->DA1_REFGRD))
Endif

If IsInCallStack("MATA410")
	dDataVld := M->C5_EMISSAO
EndIf
	
If ExistBlock("OM010PRC") .And. lExec
	nResult := ExecBlock("OM010PRC",.F.,.F.,{cTabPreco,cProduto,nQtde,cCliente,cLoja,nMoeda,dDataVld,nTipo})
Else

	nScan := aScan(aUltResult,{|x| x[1]   == cTabPreco .And.;
									x[2]  == cProduto  .And.;
									x[3]  == nQtde     .And.;
									x[4]  == cCliente  .And.;
									x[5]  == cLoja     .And.;
									x[6]  == nMoeda    .And.;
									x[7]  == cFilAnt   .And.;
									x[10] == lProspect})

	If nScan == 0

		If !(Empty(cCliente) .And. nQtde == 0 )

			If lProspect

				dbSelectArea("SUS")
				dbSetOrder(1)
				If MsSeek(xFilial("SUS")+cCliente+cLoja)
					Do Case
						Case SUS->US_EST == cMvEstado
							cTpOper := "1"
						Case SUS->US_EST != cMvEstado
							If (SUS->US_EST $ cMvNorte) .And. !(cMvEstado $ cMvNorte)
								cTpOper := "3"
							Else
								cTpOper := "2"
							EndIf
					EndCase
				EndIf
			Else

				dbSelectArea("SA1")
				dbSetOrder(1)
				If MsSeek(xFilial("SA1")+cCliente+cLoja)
					Do Case
						Case SA1->A1_EST == cMvEstado
							cTpOper := "1"
						Case SA1->A1_EST != cMvEstado
							If (SA1->A1_EST $ cMvNorte) .And. !(cMvEstado $ cMvNorte)
								cTpOper := "3"
							Else
								cTpOper := "2"
							EndIf
					EndCase
				EndIf
			EndIf
		Endif

		dbSelectarea("DA1")
		dbSetOrder(1)

		#IFDEF TOP
			If TcSrvType() <> "AS/400"
				lQuery    := .T.
				cAliasDA1 := GetNextAlias()
				aStruDA1  := DA1->(dbStruct())
				cQuery    := ""

				If lGradeReal
					cQuery += "SELECT * FROM ( "
				EndIf

				cQuery += "SELECT " 
				cQuery += " * "
				cQuery += "FROM "+RetSqlName("DA1")+ " DA1 "
				cQuery += "WHERE "
				cQuery += "( DA1.DA1_DATVIG <= '"+ DtoS(dDataVld) + "' OR DA1.DA1_DATVIG = '"+Dtos(Ctod("//"))+ "' ) "
				
				If !(nQtde == 0 .And. Empty(cCliente))
					cQuery += "AND ( DA1.DA1_TPOPER = '"+cTpOper+"' OR DA1.DA1_TPOPER = '4' ) "
				Endif
				
	    		cQuery += "AND DA1.DA1_FILIAL = '"+xFilial("DA1")+"' AND "
				cQuery +=     "DA1.DA1_CODTAB = '"+cTabPreco+"' AND "
				cQuery +=     "DA1.DA1_CODPRO = '"+cProduto+"' AND "
				cQuery +=     "DA1.DA1_QTDLOT >= "+Str(nQtde,18,8)+" AND "
				cQuery +=     "DA1.DA1_ATIVO = '1' AND  "
				cQuery +=     "DA1.D_E_L_E_T_ = ' ' "
				
				If lGradeReal
					cQuery += " UNION "
					cQuery += "SELECT * "
					cQuery += "FROM "+RetSqlName("DA1")+ " DA1 "
					cQuery += "WHERE "
					cQuery += "DA1.DA1_FILIAL = '"+xFilial("DA1")+"' AND "
					cQuery += "DA1.DA1_CODTAB = '"+cTabPreco+"' AND "
					cQuery += "DA1.DA1_REFGRD = '"+cProdRef+"' AND "
					cQuery += "DA1.DA1_QTDLOT >= "+Str(nQtde,18,8)+" AND "
					cQuery += "DA1.DA1_ATIVO = '1' AND  "
					cQuery += "( DA1.DA1_DATVIG <= '"+DtoS(dDataVld)+ "' OR DA1.DA1_DATVIG = '"+Dtos(Ctod("//"))+ "' ) AND "

					If !(nQtde == 0 .And. Empty(cCliente))
						cQuery += "( DA1.DA1_TPOPER = '"+cTpOper+"' OR DA1.DA1_TPOPER = '4' ) AND "
					Endif

					cQuery += "DA1.D_E_L_E_T_ = ' ' "
					cQuery += "AND NOT EXISTS ( "
					cQuery += "SELECT DA1B.DA1_CODPRO  "
					cQuery += "FROM "+RetSqlName("DA1")+ " DA1B "
					cQuery += "WHERE "
					cQuery += "DA1B.DA1_FILIAL = '"+xFilial("DA1")+"' AND "
					cQuery += "DA1B.DA1_CODTAB = '"+cTabPreco+"' AND "
					cQuery += "DA1B.DA1_CODPRO = '"+cProduto+"' AND "
					cQuery += "DA1B.DA1_QTDLOT >= "+Str(nQtde,18,8)+" AND "
					cQuery += "DA1B.DA1_ATIVO = '1' AND  "
					cQuery += "( DA1B.DA1_DATVIG <= '"+DtoS(dDataVld)+ "' OR DA1B.DA1_DATVIG = '"+Dtos(Ctod("//"))+ "' ) AND "

					If !(nQtde == 0 .And. Empty(cCliente))
						cQuery += "( DA1B.DA1_TPOPER = '"+cTpOper+"' OR DA1B.DA1_TPOPER = '4' ) AND "
					Endif
					cQuery += "DA1B.D_E_L_E_T_ = ' ' ) "


					cQuery += " UNION "
					cQuery += "SELECT * "
					cQuery += "FROM "+RetSqlName("DA1")+ " DA1 "
					cQuery += "WHERE "
					cQuery += "DA1.DA1_FILIAL = '"+xFilial("DA1")+"' AND "
					cQuery += "DA1.DA1_CODTAB = '"+cTabPreco+"' AND "
					cQuery += "DA1.DA1_CODPRO LIKE '"+cProduto+"%' AND "
					cQuery += "DA1.DA1_QTDLOT >= "+Str(nQtde,18,8)+" AND "
					cQuery += "DA1.DA1_ATIVO = '1' AND  "
					cQuery += "( DA1.DA1_DATVIG <= '"+DtoS(dDataVld)+ "' OR DA1.DA1_DATVIG = '"+Dtos(Ctod("//"))+ "' ) AND "

					If !(nQtde == 0 .And. Empty(cCliente))
						cQuery += "( DA1.DA1_TPOPER = '"+cTpOper+"' OR DA1.DA1_TPOPER = '4' ) AND "
					Endif

					cQuery += "DA1.D_E_L_E_T_ = ' ' "
					cQuery += "AND NOT EXISTS ( "
					cQuery += "SELECT DA1C.DA1_CODPRO  "
					cQuery += "FROM "+RetSqlName("DA1")+ " DA1C "
					cQuery += "WHERE "
					cQuery += "DA1C.DA1_FILIAL = '"+xFilial("DA1")+"' AND "
					cQuery += "DA1C.DA1_CODTAB = '"+cTabPreco+"' AND "
					cQuery += "DA1C.DA1_REFGRD = '"+cProdRef+"' AND "
					cQuery += "DA1C.DA1_QTDLOT >= "+Str(nQtde,18,8)+" AND "
					cQuery += "DA1C.DA1_ATIVO = '1' AND  "
					cQuery += "( DA1C.DA1_DATVIG <= '"+DtoS(dDataVld)+ "' OR DA1C.DA1_DATVIG = '"+Dtos(Ctod("//"))+ "' ) AND "

					If !(nQtde == 0 .And. Empty(cCliente))
						cQuery += "( DA1C.DA1_TPOPER = '"+cTpOper+"' OR DA1C.DA1_TPOPER = '4' ) AND "
					Endif
					cQuery += "DA1C.D_E_L_E_T_ = ' ' ) ) QRYDAI "

				Endif

				If (nQtde == 0 .And. Empty(cCliente))
					cQuery += "ORDER BY DA1_DATVIG ,"+SqlOrder(DA1->(IndexKey()))
				Else
					cQuery += "ORDER BY DA1_QTDLOT ,DA1_DATVIG ,"+SqlOrder(DA1->(IndexKey()))
				EndIf
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasDA1,.T.,.T.)

				If (cAliasDA1)->(!Eof())
					nProcessa := 1
				Else
					SB1->(dbSetOrder(1))
					If SB1->(MsSeek(xFilial("SB1")+cProduto))
						cGrupo := SB1->B1_GRUPO
						If !Empty(cGrupo)
							(cAliasDA1)->(dbCloseArea())
							cAliasDA1 := GetNextAlias()

							cQuery := "SELECT * "
							cQuery += "FROM "+RetSqlName("DA1")+ " DA1 "
							cQuery += "WHERE "
							cQuery += "DA1_FILIAL = '"+xFilial("DA1")+"' AND "
							cQuery += "DA1_CODTAB = '"+cTabPreco+"' AND "
							If cPaisLoc == "BRA"
								cQuery += "DA1_GRUPO = '"+cGrupo+"' AND "
							EndIf
							cQuery += "DA1_QTDLOT >= "+Str(nQtde,18,8)+" AND "
							cQuery += "DA1_ATIVO = '1' AND  "
				    		cQuery += "( DA1_DATVIG <= '"+DtoS(dDataVld)+ "' OR DA1_DATVIG = '"+Dtos(Ctod("//"))+ "' ) AND "
							If !(nQtde == 0 .And. Empty(cCliente))
								cQuery += "( DA1_TPOPER = '"+cTpOper+"' OR DA1_TPOPER = '4' ) AND "
							Endif
							cQuery += "DA1.D_E_L_E_T_ = ' ' "
							cQuery += "ORDER BY "+SqlOrder(DA1->(IndexKey()))

							cQuery := ChangeQuery(cQuery)

							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasDA1,.T.,.T.)

							If (cAliasDA1)->(!Eof())
								nProcessa := 2
							EndIf
						EndIf
					EndIf
				Endif
				For nY := 1 To Len(aStruDA1)
					If aStruDA1[nY,2]<>"C"
						TcSetField(cAliasDA1,aStruDA1[nY,1],aStruDA1[nY,2],aStruDA1[nY,3],aStruDA1[nY,4])
					EndIf
				Next nY
			Else
		#ENDIF
				lSeekDA1:= aPesqDA1(cTabPreco,cProduto)
				If lSeekDA1
					nProcessa := 1
				Else
					SB1->(dbSetOrder(1))
					If SB1->(MsSeek(xFilial("SB1")+cProduto))
						cGrupo := SB1->B1_GRUPO
						If !Empty(cGrupo)
							dbSelectarea("DA1")
							dbSetOrder(4)
							If MsSeek(xFilial("DA1")+ cTabPreco + cGrupo)
								nProcessa := 2
							EndIf
						EndIF
					Endif
				EndIf
		#IFDEF TOP
			Endif
		#ENDIF

		If nProcessa > 0

			If nQtde == 0 .And. Empty(cCliente)
				dbSelectArea(cAliasDA1)
				While (cAliasDA1)->(!Eof())
					nPrcVen   := (cAliasDA1)->DA1_PRCVEN
					nMoedaTab := (cAliasDA1)->DA1_MOEDA
					nFator    := (cAliasDA1)->DA1_PERDES
					lPrcDA1   := .T.
					dbSelectArea(cAliasDA1)
					dbSkip()
				Enddo
			Else

				dbSelectArea(cAliasDA1)
				While (cAliasDA1)->(!Eof()) .And. (cAliasDA1)->DA1_FILIAL == xFilial("DA1") .And.;
									(cAliasDA1)->DA1_CODTAB == cTabPreco .And.;
									If(nProcessa==1,Left((cAliasDA1)->DA1_CODPRO,nTamProd)== cProduto .Or. (cAliasDA1)->DA1_CODPRO==cProduto .Or. (cAliasDA1)->DA1_REFGRD == cProdRef,(cAliasDA1)->DA1_GRUPO==cGrupo)

					If nQtde <= (cAliasDA1)->DA1_QTDLOT .And. (cAliasDA1)->DA1_ATIVO == "1"

						If Empty((cAliasDA1)->DA1_ESTADO) .And. ((cAliasDA1)->DA1_TPOPER == cTpOper .Or. (cAliasDA1)->DA1_TPOPER == "4")

							nQtdLote := (cAliasDA1)->DA1_QTDLOT

							While (cAliasDA1)->(!Eof()) .And. (cAliasDA1)->DA1_FILIAL == xFilial("DA1") .And.;
																(cAliasDA1)->DA1_CODTAB == cTabPreco .And.;
																If(nProcessa==1,Left((cAliasDA1)->DA1_CODPRO,nTamProd)== cProduto .Or. (cAliasDA1)->DA1_CODPRO==cProduto .Or. (cAliasDA1)->DA1_REFGRD == cProdRef ,(cAliasDA1)->DA1_GRUPO==cGrupo) .And.;
																(cAliasDA1)->DA1_QTDLOT == nQtdLote .And.;
																(cAliasDA1)->DA1_DATVIG <= dDataVld
								If nQtde <= (cAliasDA1)->DA1_QTDLOT .And. (cAliasDA1)->DA1_ATIVO == "1" .And.;
									((!Empty((cAliasDA1)->DA1_ESTADO) .And. ( If(lProspect, SUS->US_EST, If(lSA1EstE, SA1->A1_ESTE, SA1->A1_EST)) == (cAliasDA1)->DA1_ESTADO )).Or.(Empty((cAliasDA1)->DA1_ESTADO) .And. ((cAliasDA1)->DA1_TPOPER == cTpOper .Or. (cAliasDA1)->DA1_TPOPER == "4")))

									nPrcVen   := (cAliasDA1)->DA1_PRCVEN
									nMoedaTab := (cAliasDA1)->DA1_MOEDA
									nFator    := (cAliasDA1)->DA1_PERDES

									lPrcDA1   := .T.
								EndIf

								dbSelectArea(cAliasDA1)
								dbSkip()
							Enddo
							If lPrcDA1
								Exit
							Endif

						ElseIf !Empty((cAliasDA1)->DA1_ESTADO) .And. ( If(lProspect, SUS->US_EST, If(lSA1EstE, SA1->A1_ESTE, SA1->A1_EST)) == (cAliasDA1)->DA1_ESTADO )

							nQtdLote := (cAliasDA1)->DA1_QTDLOT

							While (cAliasDA1)->(!Eof()) .And. (cAliasDA1)->DA1_FILIAL == xFilial("DA1") .And.;
																	(cAliasDA1)->DA1_CODTAB == cTabPreco .And.;
																	If(nProcessa==1,Left((cAliasDA1)->DA1_CODPRO,nTamProd)== cProduto .Or. (cAliasDA1)->DA1_CODPRO==cProduto .Or. (cAliasDA1)->DA1_REFGRD == cProdRef,(cAliasDA1)->DA1_GRUPO==cGrupo) .And.;
																	(cAliasDA1)->DA1_QTDLOT == nQtdLote .And.;
																	(cAliasDA1)->DA1_DATVIG <= dDataVld
								If nQtde <= (cAliasDA1)->DA1_QTDLOT .And. (cAliasDA1)->DA1_ATIVO == "1" .And.;
									((!Empty((cAliasDA1)->DA1_ESTADO) .And. ( If(lProspect, SUS->US_EST, If(lSA1EstE, SA1->A1_ESTE, SA1->A1_EST)) == (cAliasDA1)->DA1_ESTADO )).Or.(Empty((cAliasDA1)->DA1_ESTADO) .And. ((cAliasDA1)->DA1_TPOPER == cTpOper .Or. (cAliasDA1)->DA1_TPOPER == "4")))


									nPrcVen   := (cAliasDA1)->DA1_PRCVEN
									nMoedaTab := (cAliasDA1)->DA1_MOEDA
									nFator    := (cAliasDA1)->DA1_PERDES

									lPrcDA1   := .T.

								Endif

								dbSelectArea(cAliasDA1)
								dbSkip()
							Enddo
							If lPrcDA1
								Exit
							Endif

						EndIf
					EndIf
					dbSelectArea(cAliasDA1)
					dbSkip()
				Enddo

				If nTipo == 1
					If nPrcVen == 0 .And. !lPrcDA1
						If lLjcnvB0 .AND. nModulo == 12
							DbSelectArea("SB0")
							DbSetOrder(1)
							If DbSeek(xFilial("SB0")+cProduto)
								nPrcVen := SB0->B0_PRV1
							EndIf
						// No FrontLoja, ?obrigat?io ler o SBI
						ElseIf lR5 .AND. nModulo == 23 .And. !lPOS
							DbSelectArea("SBI")
							SBI->(DbSetOrder(1))
							If SBI->(DbSeek(xFilial("SBI")+cProduto))
								nPrcVen := SBI->BI_PRV
							EndIf
						Else
							DbSelectArea("SB1")
							SB1->(DbSetOrder(1))
							If SB1->(MsSeek(xFilial("SB1")+cProduto))
								nPrcVen := SB1->B1_PRV1
							EndIf
						EndIf
						lUltResult := .F.
					Endif
				Endif

			EndIf
		Else
			If nTipo == 1
				If nPrcVen == 0 .And. !lPrcDA1
					If lLjcnvB0 .AND. lR5 .AND. nModulo == 12
						DbSelectArea("SB0")
						DbSetOrder(1)
						If DbSeek(xFilial("SB0")+cProduto)
							nPrcVen := SB0->B0_PRV1
						EndIf
					// No FrontLoja, ?obrigat?io ler o SBI
					ElseIf lR5 .AND. nModulo == 23 .AND. !lPOS
						DbSelectArea("SBI")
						DbSetOrder(1)
						If DbSeek(xFilial("SBI")+cProduto)
							nPrcVen := SBI->BI_PRV
						EndIf
					Else
						DbSelectArea("SB1")
						DbSetOrder(1)
						If MsSeek(xFilial("SB1")+cProduto)
							nPrcVen := SB1->B1_PRV1
						EndIf
					EndIf
				EndIf
			Endif
			lUltResult := .F.
		EndIf

		nFator := Iif( nFator == 0, 1, nFator )

		If nTipo == 1
			nResult := xMoeda(nPrcVen,nMoedaTab,nMoeda,,TamSx3("D2_PRCVEN")[2])
		Else
			nResult	:= nFator
		Endif

		If lUltResult
			aadd(aUltResult,{cTabPreco,cProduto,nQtde,cCliente,cLoja,nMoeda,cFilAnt,nResult,nFator,lProspect})
			If Len(aUltResult) > MAXSAVERESULT
				aUltResult := aDel(aUltResult,1)
				aUltResult := aSize(aUltResult,MAXSAVERESULT)
			EndIf
		EndIf
	Else

		If nTipo == 1
			nResult := aUltResult[nScan,8]
		Else
			nResult := aUltResult[nScan,9]
		Endif
	EndIf
Endif
If lQuery
	dbSelectArea(cAliasDA1)
	dbCloseArea()
	dbSelectArea("DA1")
Endif

RestArea(aAreaSB1)
RestArea(aArea)

Return(nResult)

/*/{Protheus.doc} XLj7CalcQtd
(long_description)
@author j2a.luizjunior
@since 26/01/2018
@version 1.0
@example
(examples)
@see (links_or_references)
/*/

Static Function XLj7CalcQtd(aCols,nLinha,nQuant)

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")    
Local nX 		:= 1 
Local nAuxQuant := 0
Local nPosQuant	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]	// Posicao da Quantidade  
Default nQuant  := 0    
Default nLinha  := 0

For nX := 1 To Len(aCols)   
   
	If !aCols[nX][Len(aCols[nX])]
		
		If nLinha == nX	.AND. nQuant > 0 
			nAuxQuant += nQuant
		Else
			nAuxQuant += aCols[nX][nPosQuant]
		EndIf		       
		
    EndIf       
    
Next nX
                           
Return (nAuxQuant)

/*/{Protheus.doc} xLj7T_Subtotal
(long_description)
@author j2a.luizjunior
@since 26/01/2018
@version 1.0
@param nTipo, numérico, (Descrição do parâmetro)
@param uParam, ${param_type}, (Descrição do parâmetro)
@return ${return}, ${return_description}
@example
(examples)
@see (links_or_references)
/*/

Static Function xLj7T_Subtotal( nTipo, uParam )

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")

If !xLj7T_VlTp(nTipo, "xLj7T_Subtotal", uParam)
	Return .F.
EndIf
     
Return xLj7T_Array( 1, nTipo, uParam ) 

/*/{Protheus.doc} xLj7T_Array
(long_description)
@author j2a.luizjunior
@since 26/01/2018
@version 1.0
@param nLinha, numérico, (Descrição do parâmetro)
@param nColuna, numérico, (Descrição do parâmetro)
@param uParam, ${param_type}, (Descrição do parâmetro)
@return ${return}, ${return_description}
@example
(examples)
@see (links_or_references)
/*/

Static Function xLj7T_Array( nLinha, nColuna, uParam )

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")

If uParam = Nil
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Retorna os valores											 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Return aTotais[nLinha, nColuna]
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Altera os valores e da o refresh							 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aTotais[nLinha, nColuna] := uParam
	
	If nColuna = 1
		If aTotais[nLinha, 5] <> Nil
			aTotais[nLinha, 5]:Refresh()
		Endif
	ElseIf nColuna <> 3
		If aTotais[nLinha, 3] <> Nil
			aTotais[nLinha, 3]:Refresh()
		Endif
	EndIf
EndIf
Return (NIL)

/*/{Protheus.doc} xLj7T_VlTp
(long_description)
@author j2a.luizjunior
@since 26/01/2018
@version 1.0
@param nTipo, numérico, (Descrição do parâmetro)
@param cNome, character, (Descrição do parâmetro)
@param uValor, ${param_type}, (Descrição do parâmetro)
@return ${return}, ${return_description}
@example
(examples)
@see (links_or_references)
/*/

Static Function xLj7T_VlTp( nTipo, cNome, uValor )

Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
Local lRet 		:= .T.							// Retorno da funcao
Local lAutoExA	:= IsBlind()					// Verifica se a rotina sera executada via execauto ou nao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ O valor 4 representa o total de colunas do array aTotais	 ³
//³ Esta quantidade SOMENTE deve ser alterada pela equipe de 	³
//³ desenvolvimento.											 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipo <= 0 .OR. nTipo > 6
	If !lAutoExA     
		Aviso(	"Inconsistencia",; //"Inconsistencia"
				"Esta sendo enviado para a funcao " + cNome + " um TIPO que nao existe." + CRLF +; //"Esta sendo enviado para a funcao "###" um TIPO que nao existe."
				"Isto podera ocasionar um erro no sistema."	+ CRLF +; //"Isto podera ocasionar um erro no sistema."
				"Verifique o 1o parametro dessa funcao", {"OK"}) //"Verifique o 1o parametro dessa funcao"###"OK"
	Else
		ConOut("Esta sendo enviado para a funcao " + cNome + " um TIPO que nao existe." + CRLF + "Isto podera ocasionar um erro no sistema." + CRLF + "Verifique o 1o parametro dessa funcao")
	EndIf
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se o parametro para atualizacao nao e NIL entao precisa ser	 ³
//³ avaliado se o tipo X parametro sao compativeis				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If uValor <> Nil
	Do Case
		Case (nTipo == 1 .OR. nTipo = 4) .AND. ValType( uValor ) <> "C"
			lRet := .F.

		Case nTipo == 2 .AND. ValType( uValor ) <> "N"
			lRet := .F.

		Case nTipo == 3 .AND. ValType( uValor ) <> "O"
			lRet := .F.
	EndCase
	
EndIf

If !lRet
	If !lAutoExA     
		Aviso(	"Inconsistencia",; //"Inconsistencia"
				"Esta sendo enviado para a funcao " + cNome + " um TIPO incompativel" + CRLF +; //"Esta sendo enviado para a funcao "###" um TIPO incompativel"
				"com o valor a ser recebido." + CRLF +; //"com o valor a ser recebido."
				"Isto podera ocasionar um erro no sistema." + CRLF +; //"Isto podera ocasionar um erro no sistema."
				"Verifique o - 2o parametro dessa funcao", {"OK"}) //"Verifique o - 2o parametro dessa funcao"###"OK"
	Else
		ConOut("Esta sendo enviado para a funcao " + cNome + " um TIPO incompativel" + CRLF + "com o valor a ser recebido." + CRLF + "Isto podera ocasionar um erro no sistema." + CRLF + "Verifique o - 2o parametro dessa funcao")
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} XLj7T_Quant
(long_description)
@author j2a.luizjunior
@since 26/01/2018
@version 1.0
@param nTipo, numérico, (Descrição do parâmetro)
@param uParam, ${param_type}, (Descrição do parâmetro)
@return ${return}, ${return_description}
@example
(examples)
@see (links_or_references)
/*/

Static Function XLj7T_Quant(nTipo,uParam)

	Local cEstat := U_SFGN001A(ProcName(0), "SF0517X")
	
	If !xLj7T_Vltp(nTipo,"Lj7T_Quant",uParam)
		Return .F.
	EndIf

Return xLj7T_Array(7,nTipo,uParam)
