#INCLUDE "TOTVS.CH"

/*/{Protheus.doc} SF06A56X
	@description Listagem de atendimentos realizados.
	@type User Function
	@author Rafael Karczevski
	@since 28/02/2020
	@version 1.0
/*/
User Function SF06A56X()

	//Declaração de cVariable dos componentes
	Private aCoBrw2 := {}
	Private aHoBrw2 := {}
	Private noBrw2  := 0

	//Declaração de Variaveis Private dos Objetos
	SetPrvt("oDlgPri","oPainel","oBrw2","oBtnSair","oBtnConf")

	//Definicao do Dialog e todos os seus componentes.
	oDlgPri    := MSDialog():New( 201,226,558,1108,"Atendimentos Realizados",,,.F.,,,,,,.T.,,,.T. )
	oPainel    := TPanel():New( 000,000,"",oDlgPri,,.F.,.F.,,,436,172,.T.,.F. )
	MHoBrw2()
	MCoBrw2()
	oBrw2      := MsNewGetDados():New(004,004,152,432,,'AllwaysTrue()','AllwaysTrue()','',,0,99,'AllwaysTrue()','','AllwaysTrue()',oPainel,aHoBrw2,aCoBrw2 )
	oBrw2:oBrowse:bLDblClick := {|| u_MMTC14XA(Posicione("ZAK", 1, xFilial("ZAK") + oBrw2:aCols[oBrw2:nAt][1], "ZAK_OBSERV")) }
	oBtnSair   := TButton():New( 156,395,"Sair"		,oPainel,{|| oDlgPri:End() },037,012,,,,.T.,,"",,,,.F. )
	oBtnConf   := TButton():New( 156,352,"Estornar"	,oPainel,{|| EstReneg() },037,012,,,,.T.,,"",,,,.F. )

	oDlgPri:Activate(,,,.T.)

Return

/*/{Protheus.doc} MHoBrw2
	@description Monta aHeader da MsNewGetDados para o Alias: ZAK
	@type User Function
	@author Rafael Karczevski
	@since 28/02/2020
	@version 1.0
/*/
Static Function MHoBrw2()

	Aadd(aHoBrw2,{"Codigo"		,"","@!",06,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Data"		,"","@!",10,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Hora"		,"","@!",05,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Gerou Reg?"	,"","@!",03,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Operador"	,"","@!",40,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Motivo"		,"","@!",40,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Observação"	,"","@!",04,0,"","","C","","" } )
	Aadd(aHoBrw2,{"Recno"		,"","@E",10,0,"","","N","","" } )

Return

/*/{Protheus.doc} MCoBrw2
	@description Monta aCols da MsNewGetDados para o Alias: ZAK
	@type User Function
	@author Rafael Karczevski
	@since 28/02/2020
	@version 1.0
/*/
Static Function MCoBrw2()

	/*Local aAux := {}

	Aadd(aCoBrw2,Array(noBrw2+1))
	For nI := 1 To noBrw2
		aCoBrw2[1][nI] := CriaVar(aHoBrw2[nI][2])
	Next
	aCoBrw2[1][noBrw2+1] := .F.*/

	Private cAlTMP := GetNextAlias()
	If Select(cAlTMP) > 0
		(cAlTMP)->(DbCloseArea())
	EndIf
	aCoBrw2 := {}
	BeginSql Alias cAlTMP
		SELECT DISTINCT
			ZAK_COD,
			ZAK_DATA,
			ZAK_HORA,
			ZAF_NOME,
			ZAH_DESCRI,
			ZAL.R_E_C_N_O_ AS ZALREC,
			ZAM_NUM,
			E1_NUM,
			"MEMO" AS OBS
		FROM %Table:ZAK% ZAK
		INNER JOIN %Table:ZAF% ZAF
			ON ZAF_COD = ZAK_CODOPE
			AND ZAF.%NotDel%
		INNER JOIN %Table:ZAH% ZAH
			ON ZAH_COD = ZAK_CODMOT
			AND ZAF.%NotDel%
		LEFT JOIN %Table:ZAL% ZAL
			ON ZAL_CODATE = ZAK_COD
			AND ZAL.%NotDel%
		LEFT JOIN %Table:ZAM% ZAM
			ON ZAM_CODNEG = ZAL_COD
			AND ZAM_OPER = 'G'
			AND ZAM.%NotDel%
		LEFT JOIN %Table:SE1% SE1 
			ON E1_FILIAL = ZAM_FILTIT 
			AND E1_CLIENTE = ZAK_CLIENT 
			AND E1_LOJA = ZAK_LOJA 
			AND E1_NUM = ZAM_NUM
			AND E1_PREFIXO = ZAM_PREFIX
			AND E1_PARCELA = ZAM_PARCEL
			AND SE1.%NotDel%
		WHERE
			ZAK_CLIENT = %Exp:SA1->A1_COD%
			AND ZAK_LOJA = %Exp:SA1->A1_LOJA%
			AND ZAK.%NotDel%
	EndSql
	dbSelectArea(cAlTMP)
	(cAlTMP)->(DbGoTop())

	While (cAlTMP)->(! Eof())
		Aadd(aCoBrw2,{(cAlTMP)->(ZAK_COD),dToC(sToD((cAlTMP)->(ZAK_DATA))),(cAlTMP)->(ZAK_HORA),VerifE1(),;
					(cAlTMP)->(ZAF_NOME),(cAlTMP)->(ZAH_DESCRI),(cAlTMP)->(OBS),(cAlTMP)->(ZALREC),.F.})
		
		(cAlTMP)->(DbSkip())
	EndDo

	If Select(cAlTMP) > 0
		(cAlTMP)->(DbCloseArea())
	EndIf

Return

/*/{Protheus.doc} VerifE1
	@description Verifica para status de gerado renegociação
	@type Static Function
	@author Rafael Karczevski
	@since 02/03/2020
	@version 1.0
/*/
Static Function VerifE1()

	Local cRet := "NÃO"
	If !Empty((cAlTMP)->(ZAM_NUM)) .and. !Empty((cAlTMP)->(E1_NUM))
		cRet := "SIM"
	ElseIf !Empty((cAlTMP)->(ZAM_NUM)) .and. Empty((cAlTMP)->(E1_NUM))
		cRet := "CAN"
	ElseIf Empty((cAlTMP)->(ZAM_NUM)) .and. Empty((cAlTMP)->(E1_NUM))
		cRet := "NÃO"
	EndIf

Return cRet

/*/{Protheus.doc} EstReneg
	@description Função Utilizada para realizar o estorno da renegociação
	@type Static Function
	@author Rafael Karczevski
	@since 02/03/2020
	@version 1.0
/*/
Static Function EstReneg()

	Local aButtons := {}
	Local _cFilter := ""
	Local nRecno := oBrw2:aCols[oBrw2:nAt][8]
	Static tela
	Private aHeaderEx := {}
	Private aColsEx := {}

	dbSelectArea("ZAL")
	ZAL->(dbGoTo(nRecno))
	If ZAL->(!Eof())
		DEFINE MSDIALOG tela TITLE "Cobrança" FROM 000, 000  TO 500, 700 COLORS 0, 16777215 PIXEL

		fMSNewGe1()//fMSNewGe1()
		RegToMemory("ZAL", .F., .F.)
		fZALFld()
		EnchoiceBar(tela, {|| Estornar(),Tela:End() }, {|| tela:End() },,aButtons)

		ACTIVATE MSDIALOG tela CENTERED
	Else
		Alert( "Cliente nao possui negociacao confirmada" )
	EndIf

Return

/*/{Protheus.doc} MMTC14XA
    @description Abre uma janela para visualização de detalhes (Campo Memo)
    @type  User Function
    @author Rafael Karczevski
    @since 26/10/2018
    @version 1.0
    @param param, param_type, param_descr
    /*/
User Function MMTC14XA(p_cTexto)
    //u_CH003PZ("Teste")
    Private cMultGet
    cMultGet := p_cTexto
    SetPrvt("oDlg1","oPainel","oMGet1")
    oDlg1      := MSDialog():New( 247,667,597,1310,"Visualizaï¿½ï¿½o de Detalhes",,,.F.,,,,,,.T.,,,.T. )
    oPainel    := TPanel():New( 000,000,"",oDlg1,,.F.,.F.,,,316,168,.T.,.F. )
    oMultGet   := TMultiGet():New( 004,004,{|u| If(PCount()>0,cMultGet:=u,cMultGet)},oPainel,308,160,,,CLR_BLACK,CLR_WHITE,,.T.,"",,,.F.,.F.,.T.,,,.F.,,  )
    oDlg1:Activate(,,,.T.)
    
Return

Static Function fMSNewGe1()
	//------------------------------------------------
	Local nX
	Local aFieldFill := {}
	Local aFields := {}
	Local aAlterFields := {}
	Local _nCampos := 0
	Static oMSNewGe1

	// Define field properties
	DbSelectArea("SX3")
	SX3->(DbSetOrder(1))
	SX3->(DbSeek("ZAM") )
	While SX3->X3_ARQUIVO = "ZAM"
		If X3USO(X3_USADO) .AND. cNivel >= x3_nivel
			Aadd(aHeaderEx, {AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,;
				SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_F3,SX3->X3_CONTEXT,SX3->X3_CBOX,SX3->X3_RELACAO})
			_nCampos++ // CONTAGEM DE QUANTIDADE DE CAMPOS QUE IRAO APARECER.
		Endif
		SX3->(dbSkip())
	EndDo

	// Define field values
	dbSelectArea("ZAM")
	ZAM->( dbSetOrder(1) )
	If ZAM->( dbSeek(xFilial("ZAM")+ZAL->ZAL_COD) )
		While ZAM->ZAM_CODNEG = ZAL->ZAL_COD
			aadd(aFieldFill , Array(_nCampos + 1) )

			_nQuant := Len(aFieldFill)
			For _nx := 1 to _nCampos
				aFieldFill[_nQuant , _nx] := ZAM->&(aHeaderEx[_nx,2])
			Next
			aFieldFill[_nQuant , _nCampos + 1] := .F.
			ZAM->(dbSkip())
		EndDo
	EndIf

	aColsEx := aFieldFill

	oMSNewGe1 := MsNewGetDados():New( 136, 005, 240, 340, , "AllwaysTrue", "AllwaysTrue", "+Field1+Field2", aAlterFields,, 999, "AllwaysTrue", "", "AllwaysTrue", tela, aHeaderEx, aColsEx)

Return

//------------------------------------------------
Static Function fZALFld()
	//------------------------------------------------
	Local aFields := {}
	Local aAlterFields := {}
	Static oZALFld

	oZALFld := MsMGet():New("ZAL",0,1,,,,aFields,{40,5,130,340},aAlterFields,,,,,tela,,.T.)

Return

Static Function Estornar()
	Local aCols := aColsEx
	Local aHeader := aHeaderEx
	Local _lSaldoDif := .F. // VARIAVEL DE CONTROLE PARA SALDO DIFERENTE SE FOR .T. EXISTE TITULOS QUE JA FOI PAGO E POR ISSO NAO FARA ESTORNO DA  NEGOCIACAO
	Local _lTitGer := .T.
	Local _lFilant := .F.
	Local lOk := .T.

	Private nPosPref	:= aScan(aHeader, {|x| AllTrim(x[2]) == Upper("ZAM_PREFIX")} )
	Private nPosNum		:= aScan(aHeader, {|x| AllTrim(x[2]) == Upper("ZAM_NUM")} )
	Private nPosParc	:= aScan(aHeader, {|x| AllTrim(x[2]) == Upper("ZAM_PARCEL")} )
	Private nPosTipo	:= aScan(aHeader, {|x| AllTrim(x[2]) == Upper("ZAM_TIPO")} )
	Private nPosOper	:= aScan(aHeader, {|x| AllTrim(x[2]) == Upper("ZAM_OPER")} )
	Private nPosFilt	:= aScan(aHeader, {|x| AllTrim(x[2]) == Upper("ZAM_FILTIT")} )

	dbSelectARea("SE1")
	dbSetOrder(1)

	For _nx := 1 to Len(aCols)
		If aCols[_nx,nPosOper] == "G" // TITULOS QUE FORAM GERADOS
			_cALias := GetNextAlias()
			_cSql := " SELECT SE1.E1_FILIAL FROM "+RetSQLName("SE1")+" SE1  WHERE "
			_cSql += "  E1_PREFIXO = '"+aCols[_nx,nPosPref]+"' AND "
			_cSql += "  E1_NUM = '"+aCols[_nx,nPosNum]+"' AND "
			_cSql += "  E1_PARCELA = '"+aCols[_nx,nPosParc]+"' AND "
			_cSql += "  E1_TIPO = '"+aCols[_nx,nPosTipo]+"' AND "
			_cSql += "  D_E_L_E_T_ = ' ' "
			DbUseArea(.T., "TOPCONN", TCGenQry(,,ChangeQuery(_cSql)), _cALias, .F., .F.)
			_cFilial := (_cAlias)->E1_FILIAL
			(_cAlias)->( dbCloseArea() )

			If _cFilial != cFilAnt .AND. !Empty(_cFilial) // verifica se estorno esta sendo feito na mesma filial que realizou a negociacao
				_lFilant := .T. // para o usuario realizar o estorno é necessário estar na mesma filial que realizou o atendimento.
				exit
			Endif

			If SE1->( dbSeek(_cFilial+aCols[_nx,nPosPref]+aCols[_nx,nPosNum]+aCols[_nx,nPosParc]+aCols[_nx,nPosTipo] ) )
				If SE1->E1_VALOR <> SE1->E1_SALDO // VERIFICACAO SE TITULO JA FOI PAGO INTEGRAL OU PARCIALMENTE.
					_lSaldoDif := .T.
					exit
				EndIf
			Else
				_lTitGer := .F.
				exit
			EndIf
		EndIf
	Next
	If _lFilant
		Alert("Renegociação feita na loja "+_cFilial+CRLF+;
			"o estorno deve ser realizado logado na filial da renegociação!")
		Return
	Endif

	If !_lTitGer
		Alert( "Os titulos negociados foram cancelados." )
		Return
	EndIf

	If _lSaldoDIf
		Alert("Os titulos gerados ja foram recebidos, estorno nao pode ser efetuado")
		Return
	EndIf

	If !MsgYesNo("Confirmar estorno da negociacao?")
		Return
	EndIf

	For _nx := 1 to Len(aCols)
		If SE1->(dbSeek(cFilAnt+aCols[_nx,nPosPref]+aCols[_nx,nPosNum]+aCols[_nx,nPosParc]+aCols[_nx,nPosTipo]))
			If SE1->E1_SITUACA <> "0"
				MsgAlert("Titulo em carteira, não será possivel realizar o estorno da negociação.","[Fonte: SF06A58X]")
				lOk := .F.
			EndIf
		EndIf
	Next

	If lOk
		Begin Transaction

			For _nx := 1 to Len(aCols)
				_cChave := aCols[_nx,nPosPref]+aCols[_nx,nPosNum]+aCols[_nx,nPosParc]+aCols[_nx,nPosTipo]
				If aCols[_nx,nPosOper] == "G" .and. lOk// TITULOS QUE FORAM GERADOS SERAO EXCLUIDOS
					lMsErroAuto := .F.
					_cALias := GetNextAlias()
					_cSql := " SELECT SE1.E1_FILIAL FROM "+RetSQLName("SE1")+" SE1  WHERE "
					_cSql += "  E1_PREFIXO = '"+aCols[_nx,nPosPref]+"' AND "
					_cSql += "  E1_NUM = '"+aCols[_nx,nPosNum]+"' AND "
					_cSql += "  E1_PARCELA = '"+aCols[_nx,nPosParc]+"' AND "
					_cSql += "  E1_TIPO = '"+aCols[_nx,nPosTipo]+"' AND "
					_cSql += "  D_E_L_E_T_ = ' ' "
					DbUseArea(.T., "TOPCONN", TCGenQry(,,ChangeQuery(_cSql)), _cALias, .F., .F.)
					_cFilial := (_cAlias)->E1_FILIAL
					(_cAlias)->( dbCloseArea() )

					aDados:={	{"E1_FILIAL"  ,_cFilial		,Nil},;
						{"E1_PREFIXO" ,aCols[_nx,nPosPref]		,Nil},;
						{"E1_NUM"	  ,aCols[_nx,nPosNum]		,Nil},;
						{"E1_PARCELA" ,aCols[_nx,nPosParc]     ,Nil},;
						{"E1_CLIENTE"	,SA1->A1_COD  ,Nil},;
						{"E1_LOJA"		,SA1->A1_LOJA ,Nil},;
						{"E1_TIPO"    ,aCols[_nx,nPosTipo]    	,Nil}}

					MsgRun( "Excluindo título " + _cChave,'Aguarde', {|| 	CursorWait(),;
						MSExecAuto({|x,y,z|Fina040(x,y,z)},aDados,5),;
						CursorArrow() } )

					If lMsErroAuto
						lOk := .F.
						Alert("Erro na execução da exclusao do titulo. Contate o administrador do sistema.")
						MostraErro()
						DisarmTransaction()
						Break
						Exit
					EndIf


				ElseIf aCols[_nx,nPosOper] == "B" .and. lOk// TITULOS QUE FORAM BAIXADOS, TERAO A BAIXA EXCLUIDA
					lMsErroAuto := .F.

					//Baixa por Dacao.
					_aVetBx := {{"E1_FILIAL"	,aCols[_nx,nPosFilt]   ,Nil},;
						{"E1_PREFIXO"	,aCols[_nx,nPosPref]  ,Nil},;
						{"E1_NUM"		,aCols[_nx,nPosNum]     ,Nil},;
						{"E1_PARCELA"	,aCols[_nx,nPosParc]  ,Nil},;
						{"E1_CLIENTE"	,SA1->A1_COD  ,Nil},;
						{"E1_LOJA"		,SA1->A1_LOJA ,Nil},;
						{"E1_TIPO"	    ,aCols[_nx,nPosTipo]  ,Nil}}

					MsgRun( "Realizando a exclusao da baixa do título  " + _cChave,'Aguarde', {|| 	CursorWait(),;
						MSExecAuto({|x,y| fina070(x,y)}, _aVetBx,5),;
						CursorArrow() } )

					If lMsErroAuto
						lOk := .F.
						Alert("Erro na execução da baixa. Contacte o administrador do sistema.")
						MostraErro()
						DisarmTransaction()
						Break
						Exit
					EndIf

				EndIf
			Next

		End Transaction

		If !lMsErroAuto // apenas altera status se deu tudo certo...
			RecLock("ZAL")// ALTERACAO DO STATUS DA NEGOCIACAO
			ZAL->ZAL_STATUS := 'A'
			ZAL->ZAL_DTEST := dDataBase
			ZAL->ZAL_USERID := __cUserId
			MsUnlock("ZAL")
		EndIf
	EndIf

Return
